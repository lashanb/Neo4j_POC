<!DOCTYPE html>
<html>
<head>
  <title>Ontology Viewer Enhanced</title>
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <style>
    body {
        font-family: sans-serif;
        margin: 0;
        overflow: hidden; /* Prevent body scrollbars */
    }

    #main-container {
        display: flex;
        width: 100vw;
        height: 100vh;
    }

    #viewer-container {
      flex: 3; /* Initial size ratio */
      min-width: 300px; /* Minimum width */
      height: 100vh;
      padding: 15px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      background-color: #1f3250;
      position: relative;
    }

    #resizer {
        flex-basis: 5px;
        background-color: #dee2e6;
        cursor: col-resize;
        height: 100vh;
        border-left: 1px solid #ccc;
        border-right: 1px solid #ccc;
    }

    #sidebar {
      flex: 1; /* Initial size ratio */
      min-width: 300px; /* Minimum width */
      height: 100vh;
      padding: 15px;
      box-sizing: border-box;
      background-color: #f8f9fa;
      display: flex;
      flex-direction: column;
    }
    
    #sidebar-tabs {
        flex-shrink: 0;
    }

    .nav-link.disabled-tab {
        color: #adb5bd;
        pointer-events: none;
        cursor: default;
        background-color: #e9ecef;
    }

    #viewer-title {
      text-align: center;
      margin-bottom: 5px;
      flex-shrink: 0;
      color: #fff;
    }

    #file-name-display {
        text-align: center;
        margin-top: -5px;
        margin-bottom: 10px;
        flex-shrink: 0;
        color: #e0e0e0;
        font-weight: normal;
        font-style: italic;
    }

    #network-wrapper {
        position: absolute;
        top: 80px;
        left: 15px;
        right: 15px;
        bottom: 15px;
    }

    #network {
      width: 100%;
      height: 100%;
      background-color: #fff;
      border: none;
      border-radius: .375rem;
    }

    #node-count-display {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(255, 255, 255, 0.85);
        padding: 8px 12px;
        border-radius: 5px;
        z-index: 10;
        font-size: 0.8rem;
        max-height: 200px;
        overflow-y: auto;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    /* --- START: SCROLLING FIX --- */
    #sidebar-tab-content {
        flex-grow: 1;
        min-height: 0;
        position: relative;
    }

    .tab-pane {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
    }

    .scrollable-tab-content {
        flex-grow: 1;
        overflow-y: auto;
        padding-right: 15px;
        min-height: 0;
    }
    #ai-chat-container {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }
    #ai-chat-window {
        flex-grow: 1;
        overflow-y: auto;
        border: 1px solid #ccc;
        background-color: #fff;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: .375rem;
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-height: 0;
    }
    /* --- END: SCROLLING FIX --- */


    /* Custom Scrollbar Styling */
    .scrollable-tab-content::-webkit-scrollbar,
    #ai-chat-window::-webkit-scrollbar {
      width: 8px;
    }
    .scrollable-tab-content::-webkit-scrollbar-track,
    #ai-chat-window::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 10px;
    }
    .scrollable-tab-content::-webkit-scrollbar-thumb,
    #ai-chat-window::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 10px;
    }
    .scrollable-tab-content::-webkit-scrollbar-thumb:hover,
    #ai-chat-window::-webkit-scrollbar-thumb:hover {
      background: #555;
    }


    .chat-message {
        padding: 8px 12px;
        border-radius: 18px;
        max-width: 85%;
        line-height: 1.4;
        word-wrap: break-word;
    }
    .user-message {
        background-color: #0d6efd;
        color: white;
        align-self: flex-end;
        border-bottom-right-radius: 4px;
    }
    .ai-message {
        background-color: #e9ecef;
        color: #212529;
        align-self: flex-start;
        border-bottom-left-radius: 4px;
    }
    .loading-spinner {
        display: none;
        width: 1.5rem;
        height: 1.5rem;
        border: 3px solid rgba(0,0,0,.1);
        border-top-color: #0d6efd;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        align-self: flex-start;
        margin: 10px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Compact Sidebar Styles */
    #sidebar, #sidebar .form-label, #sidebar .form-control, #sidebar .form-select, #sidebar .btn, #sidebar .form-check-label, #sidebar .small {
        font-size: 0.875rem; /* 14px */
    }
    #sidebar h5 {
        font-size: 1rem;
        margin-top: 0.8rem;
        margin-bottom: 0.2rem;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    #sidebar .form-label {
        margin-bottom: 0.1rem;
    }
    #sidebar .mt-2, #sidebar .mt-1 {
        margin-top: 0.25rem !important;
    }
    #sidebar hr {
        margin: 0.75rem 0;
    }
    .select2-container .select2-selection--single, .select2-container .select2-selection--multiple {
        font-size: 0.875rem;
        min-height: calc(1.5em + .5rem + 2px);
    }
    .select2-results__option {
        font-size: 0.875rem;
    }

    .active-indicator {
        color: #198754; /* Green */
        font-size: 1.2em;
        font-weight: bold;
    }
    .clear-btn {
        font-size: 0.7rem;
        padding: .1rem .3rem;
        line-height: 1;
    }

    /* Custom Details Popup */
    #details-popup {
        display: none;
        position: absolute;
        background-color: rgba(255, 255, 255, 0.95);
        border: 1px solid #ccc;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        padding: 15px;
        z-index: 10;
        max-width: 350px;
        word-wrap: break-word;
        font-size: 0.875rem;
    }
    #details-popup-close {
        position: absolute;
        top: 5px;
        right: 10px;
        border: none;
        background: none;
        font-size: 24px;
        font-weight: bold;
        color: #6c757d;
        cursor: pointer;
        padding: 0;
        line-height: 1;
    }
    #details-popup-content p {
        margin-bottom: 0.5rem;
    }
    #details-popup-content ul {
        list-style-type: none;
        padding-left: 10px;
        margin-bottom: 0;
    }
    #details-popup-content li {
        padding: 2px 0;
    }

    .property-filter-container {
        padding-left: 1.5rem;
        margin-top: 0.5rem;
    }
    .filter-pill {
        display: inline-flex;
        align-items: center;
        background-color: #e2e3e5;
        border: 1px solid #d6d8db;
        border-radius: 1rem;
        padding: 0.15rem 0.5rem;
        margin-right: 0.25rem;
        margin-bottom: 0.25rem;
        font-size: 0.75rem;
    }
    .remove-filter {
        margin-left: 0.35rem;
        border: none;
        background: none;
        font-weight: bold;
        cursor: pointer;
        padding: 0;
        line-height: 1;
        color: #6c757d;
    }
    .property-toggle-arrow {
        cursor: pointer;
        color: #6c757d;
        text-decoration: none;
    }
    .accordion-button {
      font-size: 0.875rem;
      padding: 0.75rem 1rem;
    }
    .accordion-body {
        font-size: 0.85rem;
    }
    .color-box {
        width: 16px;
        height: 16px;
        border: 1px solid #ccc;
        border-radius: 3px;
        display: inline-block;
        vertical-align: middle;
        margin-right: 8px;
    }
    
    /* --- START: NEW QUERY BUILDER STYLES --- */
    #query-builder-container, #aggregation-builder-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    .aggregation-row {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    
    #query-tab-pane, #query-tab-pane .form-select, #query-tab-pane .form-control, #query-tab-pane .btn, #query-tab-pane .input-group-text, #query-tab-pane .form-check-label {
        font-size: 0.75rem; /* 12px */
    }
    #query-tab-pane h5 {
        font-size: 0.9rem;
        margin-top: 0.6rem;
        margin-bottom: 0.1rem;
    }
    #query-tab-pane hr {
        margin: 0.5rem 0;
    }

    #cypher-query-display {
        background-color: #212529 !important;
        color: #f8f9fa !important;
        font-family: monospace;
        font-size: 0.7rem;
        resize: vertical;
        min-height: 100px;
        margin-top: 10px;
    }

    .query-output-item .form-check {
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .query-part-summary {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px;
        background-color: #e9ecef;
        border: 1px solid #dee2e6;
        border-radius: .375rem;
        font-size: 0.8rem;
    }
    .query-part-summary-text {
        flex-grow: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding-right: 10px;
    }
    .query-part-summary .btn-icon {
        background: none;
        border: none;
        padding: 0 4px;
        cursor: pointer;
        color: #6c757d;
    }
    .query-part-summary .btn-icon:hover {
        color: #212529;
    }
    .query-part-editor {
        border: 1px solid #dee2e6;
        border-top: none;
        border-radius: 0 0 .375rem .375rem;
        padding: 10px;
        background-color: #fff;
        margin-top: -1px;
    }
    /* --- END: NEW QUERY BUILDER STYLES --- */

    /* Query Result Modal Table Styles */
    #queryResultModalBody table {
        width: 100%;
        font-size: 0.8rem;
    }
    #queryResultModalBody th, #queryResultModalBody td {
        border: 1px solid #dee2e6;
        padding: 8px;
        white-space: pre-wrap;
        word-break: break-all;
    }
    #queryResultModalBody th {
        background-color: #f8f9fa;
    }

    /* --- START: ELASTIC SEARCH STYLES --- */
    #elastic-search-results .list-group-item {
        font-size: 0.8rem;
        padding: 0.5rem 0.75rem;
        cursor: pointer;
        border-bottom: 1px solid #eee;
    }
    #elastic-search-results .list-group-item:last-child {
        border-bottom: none;
    }
    #elastic-search-results .list-group-item:hover {
        background-color: #f8f9fa;
    }
    .search-result-nodetype {
        font-size: 0.7rem;
        color: #6c757d;
        background-color: #e9ecef;
        padding: 0.1rem 0.4rem;
        border-radius: 0.25rem;
        float: right;
    }
    .search-result-match {
        font-weight: bold;
    }
    /* --- END: ELASTIC SEARCH STYLES --- */
  </style>
</head>
<body>

<div id="main-container">
    <div id="viewer-container">
      <h4 id="viewer-title">Ontology Viewer</h4>
      <h6 id="file-name-display"></h6>
      <div id="network-wrapper">
        <div id="network"></div>
         <div id="details-popup">
            <button id="details-popup-close">&times;</button>
            <div id="details-popup-content"></div>
        </div>
        <div id="node-count-display"></div>
      </div>
    </div>

    <div id="resizer"></div>

    <div id="sidebar">
      <ul class="nav nav-tabs" id="sidebar-tabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="upload-tab" data-bs-toggle="tab" data-bs-target="#upload-tab-pane" type="button" role="tab" aria-controls="upload-tab-pane" aria-selected="true">Upload</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="analysis-tab" data-bs-toggle="tab" data-bs-target="#analysis-tab-pane" type="button" role="tab" aria-controls="analysis-tab-pane" aria-selected="false">Analysis</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="build-tab" data-bs-toggle="tab" data-bs-target="#build-tab-pane" type="button" role="tab" aria-controls="build-tab-pane" aria-selected="false">Build Ontology</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="query-tab" data-bs-toggle="tab" data-bs-target="#query-tab-pane" type="button" role="tab" aria-controls="query-tab-pane" aria-selected="false">Query</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="ask-ai-tab" data-bs-toggle="tab" data-bs-target="#ask-ai-tab-pane" type="button" role="tab" aria-controls="ask-ai-tab-pane" aria-selected="false">Ask AI</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="help-tab" data-bs-toggle="tab" data-bs-target="#help-tab-pane" type="button" role="tab" aria-controls="help-tab-pane" aria-selected="false">Help</button>
        </li>
      </ul>

      <div class="tab-content" id="sidebar-tab-content">
        <div class="tab-pane fade show active" id="upload-tab-pane" role="tabpanel" aria-labelledby="upload-tab" tabindex="0">
          <div class="scrollable-tab-content">
              <h5 class="mt-3"><strong>üíæ Load Data Source</strong></h5>
              <p class="text-muted" style="font-size: 0.75rem;">
                  Use these options to connect to a live database or upload local files. Loading from a database enables the "Ask AI" and "Query" tabs.
              </p>
              <button id="btnLoadFromDb" class="btn btn-secondary w-100 mt-2" onclick="loadFromNeo4j()">Load from Database</button>

              <input type="file" id="uploadOntology" accept=".json" class="d-none" />
              <button id="btnLoadOntology" class="btn btn-secondary w-100 mt-2">Load Ontology JSON</button>

              <input type="file" id="uploadLayout" accept=".json" class="d-none" />
              <button id="btnLoadLayout" class="btn btn-secondary w-100 mt-2">Load Layout</button>

              <input type="file" id="uploadCypher" accept=".txt,.cypher" class="d-none" />
              <button id="btnLoadCypher" class="btn btn-secondary w-100 mt-2">Load Cypher File</button>

              <input type="file" id="uploadOwl" accept=".owl,.rdf,.xml,.txt,.ttl" class="d-none" />
              <button id="btnLoadOwl" class="btn btn-secondary w-100 mt-2">Load OWL File</button>

              <button id="btnLoadCsv" class="btn btn-secondary w-100 mt-2" data-bs-toggle="modal" data-bs-target="#csvUploadModal">Upload Using CSV</button>
              
              <hr>

              <h5 class="mt-3"><strong>üìÇ Load from Configured File</strong></h5>
              <p class="text-muted" style="font-size: 0.75rem;">
                Select a pre-configured ontology file to view. This is a frontend-only operation and will disable database-dependent features.
              </p>
              <div class="input-group">
                <select id="fileOntologySelector" class="form-select" disabled>
                    <option>Loading files...</option>
                </select>
                <button class="btn btn-info" onclick="loadOntologyFromFile()">Load File</button>
              </div>
              <hr>

              <h5 class="mt-3"><strong>üß† Smart Search Settings</strong></h5>
              <small class="text-muted">This is optional and enhances the Live Search feature.</small>
              <input type="file" id="uploadSynonyms" accept=".json" class="d-none" />
              <button id="btnLoadSynonyms" class="btn btn-secondary w-100 mt-2">Load Synonym Dictionary</button>

              <hr>

              <h5 class="mt-3"><strong>‚ö° Performance Settings</strong></h5>
              <small class="text-muted">Toggle these options at any time for large graphs.</small>

              <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" value="" id="physicsToggle">
                <label class="form-check-label" for="physicsToggle">
                  <strong>Optimize Physics</strong>
                </label>
                <div class="form-text mt-0">Faster layout algorithm; less "floaty".</div>
              </div>

              <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" value="" id="renderToggle">
                <label class="form-check-label" for="renderToggle">
                  <strong>Simplify Rendering</strong>
                </label>
                <div class="form-text mt-0">Uses simple dots and straight lines to draw faster.</div>
              </div>

              <div class="form-check mt-2">
                <input class="form-check-input" type="checkbox" value="" id="clusterToggle">
                <label class="form-check-label" for="clusterToggle">
                  <strong>Enable Clustering</strong>
                </label>
                <div class="form-text mt-0">Groups dense nodes together for an easier overview.</div>
              </div>
          </div>
        </div>

        <div class="tab-pane fade" id="analysis-tab-pane" role="tabpanel" aria-labelledby="analysis-tab" tabindex="0">
          <div class="scrollable-tab-content">
              <h5>
                <strong>Live Search</strong>
                <span id="live-search-active-indicator" class="active-indicator" style="display:none;">‚úîÔ∏è</span>
                <button id="clear-live-search" class="btn btn-sm btn-outline-danger clear-btn" style="display:none;">Clear</button>
              </h5>
              <label for="elasticSearchInput" class="form-label mt-1">Search Nodes &amp; Relationships:</label>
              <div id="live-search-wrapper" style="position: relative;">
                <input type="text" id="elasticSearchInput" class="form-control" placeholder="Type to search..." autocomplete="off">
                <div id="elastic-search-results" class="list-group position-absolute w-100" style="z-index: 1000; display: none; max-height: 250px; overflow-y: auto;"></div>
              </div>
              <hr>

              <h5>
                <strong>Relationships Finder</strong>
                <span id="depth-filter-active-indicator" class="active-indicator" style="display:none;">‚úîÔ∏è</span>
                <button id="clear-depth-filter" class="btn btn-sm btn-outline-danger clear-btn" style="display:none;">Clear</button>
              </h5>
              <label for="nodeSelect" class="form-label mt-2">Select Starting Node(s):</label>
              <select id="nodeSelect" class="form-select" multiple>
                <option value="">-- Load Data First --</option>
              </select>

              <label for="depthInput" class="form-label mt-2">Relationship Depth:</label>
              <div class="input-group">
                  <input type="number" id="depthInput" class="form-control" value="1" min="0" title="Set depth for filtering">
                  <button class="btn btn-secondary" onclick="activateDepthFilter()">üéØ Filter by Depth</button>
              </div>
              <hr>

              <div class="d-flex justify-content-between align-items-center">
                  <h5>
                      <strong>Advanced Search</strong>
                      <span id="advanced-search-active-indicator" class="active-indicator" style="display:none;">‚úîÔ∏è</span>
                      <button id="clear-advanced-search" class="btn btn-sm btn-outline-danger clear-btn" style="display:none;">Clear</button>
                  </h5>
                  <a href="#" id="toggle-advanced-search-body" class="property-toggle-arrow" onclick="toggleAdvancedSearchBody(event)">
                      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-up" viewBox="0 0 16 16">
                          <path fill-rule="evenodd" d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"></path>
                      </svg>
                  </a>
              </div>

              <div class="d-flex justify-content-start gap-3 mt-2 mb-1 ms-1">
                <small class="text-muted">Node Type Logic:</small>
                <div class="form-check form-check-inline" style="font-size: 0.8rem; margin: 0; padding: 0 0 0 1.25em;">
                  <input class="form-check-input" type="radio" name="node-type-logic" id="node-type-logic-or" value="OR" checked onchange="triggerAdvancedFilter()">
                  <label class="form-check-label" for="node-type-logic-or">OR</label>
                </div>
                <div class="form-check form-check-inline" style="font-size: 0.8rem; margin: 0; padding: 0 0 0 1.25em;">
                  <input class="form-check-input" type="radio" name="node-type-logic" id="node-type-logic-and" value="AND" onchange="triggerAdvancedFilter()">
                  <label class="form-check-label" for="node-type-logic-and">AND</label>
                </div>
              </div>
              <div id="advanced-search-body">
                  <div class="d-flex justify-content-start gap-2 mb-2">
                      <a href="#" onclick="selectAllNodeTypes(event)" class="small">Select All</a>
                      <a href="#" onclick="deselectAllNodeTypes(event)" class="small">Deselect All</a>
                  </div>
                  <div id="node-type-filter-container">
                    <small class="text-muted">Load data to see types.</small>
                  </div>
              </div>
              <hr>

              <h5><strong>üõ£Ô∏è Find Path</strong></h5>
              <div class="row g-2">
                <div class="col-6">
                  <label for="pathFromTypeSelect" class="form-label">'From' Node Type:</label>
                  <select id="pathFromTypeSelect" class="form-select">
                      <option value="">-- Load Data First --</option>
                  </select>
                </div>
                <div class="col-6">
                  <label for="pathToTypeSelect" class="form-label">'To' Node Type:</label>
                  <select id="pathToTypeSelect" class="form-select">
                      <option value="">-- Load Data First --</option>
                  </select>
                </div>
                <div class="col-6">
                  <label for="pathFromNodeSelect" class="form-label">'From' Node:</label>
                  <select id="pathFromNodeSelect" class="form-select" disabled>
                      <option value="">-- Select Type First --</option>
                  </select>
                </div>
                <div class="col-6">
                  <label for="pathToNodeSelect" class="form-label">'To' Node:</label>
                  <select id="pathToNodeSelect" class="form-select" disabled>
                    <option value="">-- Select Type First --</option>
                  </select>
                </div>
              </div>
              <button class="btn btn-info w-100 mt-3" onclick="showRelationshipPath()">üîé Show Path</button>
              <hr>

              <h5><strong>Actions</strong></h5>
              <button class="btn btn-warning w-100 mt-2" onclick="resetView()">üîÑ Reset All Filters & View</button>
              <button class="btn btn-primary w-100 mt-2" onclick="downloadLayout()">üíæ Save Layout</button>
          </div>
        </div>

        <div class="tab-pane fade" id="build-tab-pane" role="tabpanel" aria-labelledby="build-tab" tabindex="0">
            <div class="scrollable-tab-content">
                <h5 class="mt-3"><strong>‚úèÔ∏è Ontology Builder</strong></h5>
                <p class="text-muted" style="font-size: 0.75rem;">
                    Use the buttons below to build your graph. Click an element on the canvas to edit it.
                </p>
                <div class="d-grid gap-2">
                    <button id="btn-add-node" class="btn btn-primary">Add Node</button>
                    <button id="btn-add-edge" class="btn btn-secondary">Add Relationship</button>
                    <hr>
                    <input type="file" id="uploadOntologyToBuild" accept=".json" class="d-none" />
                    <button id="btn-load-ontology-to-build" class="btn btn-info">Load Ontology to Edit</button>
                    <button id="btn-save-ontology" class="btn btn-success">üíæ Save Ontology</button>
                </div>
            </div>
        </div>
        
        <div class="tab-pane fade" id="query-tab-pane" role="tabpanel" aria-labelledby="query-tab" tabindex="0">
            <div class="scrollable-tab-content">
                <h5 class="mt-3"><strong>üîç Cypher Query Builder</strong></h5>
                <p class="text-muted" style="font-size: 0.75rem;">
                    The database schema is now shown in the main viewer. Use it as a reference to build your query below.
                </p>
                <div id="query-builder-container">
                    </div>
                <div class="d-flex gap-2 mt-3">
                    <button class="btn btn-sm btn-outline-primary" id="add-node-btn">Add Node</button>
                    <button class="btn btn-sm btn-outline-secondary" id="add-rel-btn" disabled>Add Relationship</button>
                </div>
                <hr>
                <h5><strong>Aggregations</strong></h5>
                <div id="aggregation-builder-container">
                    </div>
                <button class="btn btn-sm btn-outline-info mt-2" id="add-aggregation-btn">Add Aggregation</button>
                <hr>
                <h5><strong>Query Output (RETURN)</strong></h5>
                <div id="query-output-container">
                    <small class="text-muted">Add nodes/relationships to the query to select output.</small>
                </div>
                <hr>
                <h5><strong>Generated Query</strong></h5>
                <textarea id="cypher-query-display" class="form-control" rows="4">MATCH (n) RETURN n LIMIT 25</textarea>
                <button id="run-query-btn" class="btn btn-success w-100 mt-3" onclick="runGeneratedQuery()">Run Query</button>
                <button id="clear-query-btn" class="btn btn-warning w-100 mt-2">Clear Query</button>
            </div>
        </div>

        <div class="tab-pane fade" id="ask-ai-tab-pane" role="tabpanel" aria-labelledby="ask-ai-tab" tabindex="0">
          <h5 class="mt-3"><strong>ü§ñ AI Ontology Assistant</strong></h5>
          <div id="ai-chat-container">
              <div id="ai-chat-window">
                  <div class="ai-message">Ask a question about the loaded ontology...</div>
              </div>
              <div class="input-group">
                  <input type="text" id="ai-chat-input" class="form-control" placeholder="e.g., 'What is a Customer?'" onkeydown="if(event.key==='Enter') askAIChat();">
                  <button class="btn btn-primary" onclick="askAIChat()">Send</button>
              </div>
          </div>
        </div>

        <div class="tab-pane fade" id="help-tab-pane" role="tabpanel" aria-labelledby="help-tab" tabindex="0">
            <div class="scrollable-tab-content">
              <h5 class="mt-3"><strong>üôã‚Äç‚ôÇÔ∏è Help Guide</strong></h5>
              <p class="text-muted" style="font-size: 0.85rem;">Welcome to the Ontology Viewer! This tool helps you visualize and analyze graph-based data.</p>
              <div class="accordion mt-2" id="helpAccordion">
                
                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne"><strong>1. Loading Data</strong></button></h2>
                  <div id="collapseOne" class="accordion-collapse collapse show" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      Use the <strong>Upload</strong> tab to load your graph data. There are two primary modes:
                      <ul>
                        <li><strong>Database Mode:</strong> Click "Load from Database" to connect to a live Neo4j instance. This enables the powerful "Ask AI" and "Query" tab features.</li>
                        <li><strong>File Mode:</strong> Use the other options to load static files (JSON, CSV, OWL, etc.) or select a pre-configured file from the dropdown. This mode is for viewing only and disables the AI/Query tabs.</li>
                      </ul>
                      For large graphs, you can toggle the <strong>Performance Settings</strong> on this tab *before* loading to improve responsiveness.
                    </div>
                  </div>
                </div>

                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo"><strong>2. Smart Search (Optional)</strong></button></h2>
                  <div id="collapseTwo" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      You can enhance the search functionality by loading a <strong>Synonym Dictionary</strong> from the "Upload" tab.
                      <ul>
                        <li>The dictionary must be a JSON file where keys are words and values are arrays of their synonyms.</li>
                        <li>When loaded, both the main <strong>Live Search</strong> and the <strong>"Node contains"</strong> filter in Advanced Search will use these synonyms. For example, if "business" is a synonym for "commercial", searching for "business" will also find nodes containing "commercial".</li>
                      </ul>
                    </div>
                  </div>
                </div>

                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree"><strong>3. Interacting with the Graph</strong></button></h2>
                  <div id="collapseThree" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      The main viewer is interactive:
                      <ul>
                        <li><strong>Click:</strong> Click a node or edge to see its details in a popup. This also selects the node in the "Relationship Finder".</li>
                        <li><strong>Drag:</strong> Rearrange nodes by dragging them. Use "Save Layout" to save your new positions.</li>
                        <li><strong>Zoom & Pan:</strong> Use your mouse wheel to zoom in and out. Click and drag the background to pan across the graph.</li>
                      </ul>
                    </div>
                  </div>
                </div>
                
                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseEight" aria-expanded="false" aria-controls="collapseEight"><strong>4. Building an Ontology</strong></button></h2>
                  <div id="collapseEight" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      The <strong>Build Ontology</strong> tab provides a canvas to create your own graph from scratch.
                      <ul>
                        <li><strong>Add Node:</strong> Adds a new node to the canvas.</li>
                        <li><strong>Add Relationship:</strong> Puts you in a two-click mode. First, click the source node, then click the target node to create a relationship.</li>
                        <li><strong>Editing:</strong> Click any node or relationship on the canvas to open an editor panel in the sidebar. Here you can change labels, types, and add custom key-value properties.</li>
                        <li><strong>Saving:</strong> When you're finished, click <strong>Save Ontology</strong>. This will download a JSON file of your creation, which can be re-loaded later using the "Load Ontology JSON" button on the Upload tab.</li>
                      </ul>
                    </div>
                  </div>
                </div>

                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour"><strong>5. Searching & Filtering</strong></button></h2>
                  <div id="collapseFour" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      The <strong>Analysis</strong> tab contains powerful tools to explore your data.
                      <ul>
                        <li><strong>Live Search:</strong> A global search across all nodes and their properties. It's a "word-based" search, meaning it will find nodes that contain all the words in your query. It is also enhanced by the synonym dictionary.</li>
                        <li><strong>Relationship Finder:</strong> Finds all nodes within a certain number of connections ("depth") from your selected starting node(s).</li>
                        <li><strong>Advanced Search:</strong> Provides granular filtering options for each node type.
                            <ul>
                                <li>Each node type has a color key matching the graph.</li>
                                <li>You can filter by specific properties, perform a smart "Node contains" search (with synonyms), or find an exact "Name is" match.</li>
                                <li>Adding multiple filter pills for a single node type works as an <strong>OR</strong> condition (e.g., find nodes with Risk Rating "Low" OR Industry "Retail").</li>
                            </ul>
                        </li>
                         <li><strong>Filter Logic:</strong> The Relationship Finder and Advanced Search filters work together with <strong>AND</strong> logic. The final view will only show nodes that satisfy the conditions of all active filters.</li>
                      </ul>
                    </div>
                  </div>
                </div>

                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseFive" aria-expanded="false" aria-controls="collapseFive"><strong>6. Finding Paths</strong></button></h2>
                  <div id="collapseFive" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      The <strong>Find Path</strong> tool highlights the shortest path between any two nodes.
                      <ul>
                        <li>First, select the Type for the 'From' and 'To' nodes.</li>
                        <li>Then, select the specific start and end nodes from the dropdowns.</li>
                        <li>Click "Show Path" to isolate the path. This temporarily overrides other filters. Use "Reset All Filters & View" to return to the previous view.</li>
                      </ul>
                    </div>
                  </div>
                </div>
                
                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSeven" aria-expanded="false" aria-controls="collapseSeven"><strong>7. Query Builder (Database Mode)</strong></button></h2>
                  <div id="collapseSeven" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      The <strong>Query</strong> tab allows you to build Cypher queries visually. This tab is only enabled when connected to a database.
                      <ul>
                        <li>When this tab is selected, the main viewer shows the <strong>database schema graph</strong> for reference.</li>
                        <li>Click <strong>Add Node</strong> to start your query pattern.</li>
                        <li>Select a <strong>Node Type</strong> and add property filters using operators like <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, etc.</li>
                        <li>Click <strong>Add Relationship</strong> to connect to another node.</li>
                        <li>Use the <strong>Aggregations</strong> section to perform calculations like <code>COUNT</code>, <code>AVG</code>, or <code>SUM</code> on your results.</li>
                        <li>The generated Cypher query updates automatically. Click <strong>Run Query</strong> to execute it.</li>
                      </ul>
                    </div>
                  </div>
                </div>

                <div class="accordion-item">
                  <h2 class="accordion-header"><button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSix" aria-expanded="false" aria-controls="collapseSix"><strong>8. Ask AI Assistant (Database Mode)</strong></button></h2>
                  <div id="collapseSix" class="accordion-collapse collapse" data-bs-parent="#helpAccordion">
                    <div class="accordion-body">
                      Use the <strong>Ask AI</strong> tab to ask natural language questions about the loaded ontology. This feature requires a live database connection to generate and run queries. For example, you can ask "What is a Customer?" or "What is the path between Alice Johnson and L001?".
                    </div>
                  </div>
                </div>

              </div>
              <a href="#" id="further-details-link" class="btn btn-outline-primary w-100 mt-3" target="_blank" rel="noopener noreferrer">Further details here</a>
          </div>
        </div>
      </div>
    </div>
</div>

<div class="modal fade" id="builderEditModal" tabindex="-1" aria-labelledby="builderEditModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="builderEditModalLabel">Edit Element</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="modal-node-editor-section">
            <div class="mb-2">
                <label for="modal-node-label-input" class="form-label mb-0">Node Name</label>
                <input type="text" class="form-control form-control-sm" id="modal-node-label-input">
            </div>
             <div class="mb-2">
                <label for="modal-node-group-input" class="form-label mb-0">Labels (Add multiple comma seperated)</label>
                <input type="text" class="form-control form-control-sm" id="modal-node-group-input">
            </div>
            <div class="mb-2">
                <label class="form-label mb-0">Properties</label>
                <div id="modal-node-properties-container" style="max-height: 200px; overflow-y: auto;" class="p-2 border rounded"></div>
                <button id="modal-btn-add-property" class="btn btn-sm btn-outline-info w-100 mt-2">Add Property</button>
            </div>
        </div>
        <div id="modal-edge-editor-section">
             <div class="mb-2">
                <label for="modal-edge-label-input" class="form-label mb-0">Relationship Name</label>
                <input type="text" class="form-control form-control-sm" id="modal-edge-label-input">
            </div>
            <div class="mb-2">
                <label class="form-label mb-0">Properties</label>
                <div id="modal-edge-properties-container" style="max-height: 200px; overflow-y: auto;" class="p-2 border rounded"></div>
                <button id="modal-btn-add-edge-property" class="btn btn-sm btn-outline-info w-100 mt-2">Add Property</button>
            </div>
        </div>
      </div>
      <div class="modal-footer justify-content-between">
        <button type="button" id="modal-btn-delete" class="btn btn-danger">Delete</button>
        <div>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" id="modal-btn-save" class="btn btn-primary">Save Changes</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="csvUploadModal" tabindex="-1" aria-labelledby="csvUploadModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="csvUploadModalLabel">Upload Ontology from CSV</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <label for="nodesCsvFile" class="form-label">Nodes CSV File</label>
          <input class="form-control" type="file" id="nodesCsvFile" accept=".csv">
        </div>
        <div class="mb-3">
          <label for="edgesCsvFile" class="form-label">Edges CSV File</label>
          <input class="form-control" type="file" id="edgesCsvFile" accept=".csv">
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" onclick="handleCsvUpload()">Upload</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="limitModal" tabindex="-1" aria-labelledby="limitModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="limitModalLabel">Node Limit Exceeded</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>The loaded data has a large number of nodes.</p>
        <p>To ensure performance, only the <strong>first 500 nodes</strong> and their direct relationships are being displayed initially. All analysis will be performed on the complete dataset.</p>
      </div>
       <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="customAlertModal" tabindex="-1" aria-labelledby="customAlertModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="customAlertModalLabel">Alert</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="customAlertModalBody">
        ...
      </div>
       <div class="modal-footer">
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
</div>

<div class="modal fade" id="queryResultModal" tabindex="-1" aria-labelledby="queryResultModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="queryResultModalLabel">Query Results</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="queryResultModalBody">
        </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>


<script>
  // --- START: NEW HYBRID MODE LOGIC ---
  let currentDataSourceMode = 'none'; // Can be 'none', 'database', or 'file'
  // --- END: NEW HYBRID MODE LOGIC ---

  const GEMINI_API_KEY = "AIzaSyC9qqyhaCGRM_dIR_s-8HddLgWExTgW85E"; // IMPORTANT: Replace with your actual key
  const DEFAULT_SYNONYM_URL = 'my_synonyms.json'; // This is the location of your file
  let isDbConnected = false; // Tracks if data is from the database
  let fullGraph = { nodes: [], edges: [] };
  let typeProperties = {};
  let aiChatHistory = [];
  let limitModal;
  let csvUploadModal;
  let customAlertModal;
  let queryResultModal;
  let synonymDict = {};
  let queryBuilderPartCounter = 0;
  
  // --- START: APP STATE VARIABLES ---
  let cachedFullGraph = null;
  let cachedFileName = '';
  let cachedSchemaGraph = null; 
  let hasShownNodeLimitWarning = false; 
  // --- END: APP STATE VARIABLES ---

  // --- START: BUILDER STATE ---
  let isBuildMode = false;
  let buildGraph = {
      nodes: new vis.DataSet(),
      edges: new vis.DataSet()
  };
  let buildNodeCounter = 0;
  let builderEditModal;
  let tempEdgeData = null; // Used for passing data to the addEdge callback
  // --- END: BUILDER STATE ---


  // State object for the depth filter
  let depthFilterState = {
      active: false,
      nodeIds: new Set()
  };

  let network;
  const container = document.getElementById("network");
  const detailsPopup = document.getElementById('details-popup');
  const detailsPopupContent = document.getElementById('details-popup-content');
  const detailsPopupClose = document.getElementById('details-popup-close');
  const NODE_LIMIT = 500;

  function buildOptions(forBuilder = false) {
      const isPhysicsOptimized = document.getElementById('physicsToggle').checked;
      const isRenderOptimized = document.getElementById('renderToggle').checked;

      const nodeOptions = {
          shape: isRenderOptimized ? "dot" : "ellipse",
          font: { color: "#000" }
      };

      if (isRenderOptimized) {
          nodeOptions.size = 10;
      }

      const options = {
          nodes: nodeOptions,
          edges: {
              arrows: "to",
              font: { align: "middle" },
              smooth: {
                  enabled: !isRenderOptimized,
                  type: "dynamic"
              }
          },
          physics: {
              enabled: !forBuilder,
              solver: isPhysicsOptimized ? "barnesHut" : "forceAtlas2Based",
              barnesHut: {
                  gravitationalConstant: -8000,
                  springConstant: 0.001,
                  avoidOverlap: 0.1
              },
              stabilization: false
          },
          groups: {},
          interaction: {
              dragNodes: true,
              dragView: true,
              zoomView: true,
              selectConnectedEdges: false,
          },
          manipulation: {
              enabled: false,
              addEdge: function (data, callback) {
                  // This callback is triggered after a user drags an edge
                  tempEdgeData = data;
                  showBuilderEditModal({type: 'edge'}, callback);
              }
          }
      };
      
      return options;
  }

  function initNetwork() {
    const initialOptions = buildOptions();
    network = new vis.Network(container, { nodes: new vis.DataSet([]), edges: new vis.DataSet([]) }, initialOptions);

    network.on("stabilized", function () {
      if (document.getElementById('physicsToggle').checked) {
        network.setOptions({ physics: false });
      }
    });

    network.on("dragEnd", function (params) {
      if (params.nodes.length > 0) {
        const nodeId = params.nodes[0];
        const position = network.getPositions([nodeId])[nodeId];
        const dataSet = isBuildMode ? buildGraph.nodes : network.body.data.nodes;
        dataSet.update({id: nodeId, x: position.x, y: position.y, physics: false});
      }
    });

    network.on("click", function (params) {
        // --- START: BUILDER CLICK LOGIC ---
        if (isBuildMode) {
            network.disableEditMode(); // Always exit manipulation mode on click
            $('#btn-add-edge').removeClass('btn-info').addClass('btn-secondary').text('Add Relationship');
            if (params.nodes.length > 0) {
                showBuilderEditModal({ id: params.nodes[0], type: 'node' });
            } else if (params.edges.length > 0) {
                showBuilderEditModal({ id: params.edges[0], type: 'edge' });
            }
            return;
        }
        // --- END: BUILDER CLICK LOGIC ---

        let content = '';
        detailsPopup.style.display = 'none';

        if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            
            // Check if we are in schema view or data view
            const isSchemaView = cachedFullGraph !== null;
            const nodeDataSource = isSchemaView ? network.body.data.nodes : fullGraph.nodes;
            
            const node = nodeDataSource.get ? nodeDataSource.get(nodeId) : nodeDataSource.find(n => n.id === nodeId);
            
            if (node) {
                 if(!isSchemaView) {
                    $('#nodeSelect').val([nodeId]).trigger('change');
                    const nodeType = node.labels[0];
                    $('#pathFromTypeSelect').val(nodeType).trigger('change');
                    setTimeout(() => {
                        $('#pathFromNodeSelect').val(nodeId).trigger('change');
                    }, 100);
                 }

                let propertiesList = '';
                if (node.properties && typeof node.properties === 'object' && Object.keys(node.properties).length > 0) {
                    for (const [key, value] of Object.entries(node.properties)) {
                        const displayValue = Array.isArray(value) ? value.join(', ') : value;
                        propertiesList += `<li><strong>${key}:</strong> ${displayValue}</li>`;
                    }
                } else if (isSchemaView && node.description) {
                    propertiesList = ''; 
                } else {
                    propertiesList = '<li>No properties defined.</li>';
                }
                
                const titleLabel = isSchemaView ? "Node Type" : "Node";
                const typeLabel = isSchemaView ? "Group" : "Type(s)";
                const typeValue = isSchemaView ? node.group : node.labels.join(', ');

                content = `
                    <p><strong>${titleLabel}:</strong> ${node.label}</p>
                    <p><strong>${typeLabel}:</strong> ${typeValue}</p>
                    <p><strong>Description:</strong> ${node.description || 'N/A'}</p>
                    ${!isSchemaView ? `<div><strong>Properties:</strong><ul>${propertiesList}</ul></div>` : ''}
                `;
            }
        } else if (params.edges.length > 0) {
            const edgeId = params.edges[0];
            const isSchemaView = cachedFullGraph !== null;
            const edgeDataSource = isSchemaView ? network.body.data.edges : fullGraph.edges;
            const nodeDataSource = isSchemaView ? network.body.data.nodes : fullGraph.nodes;

            const edge = edgeDataSource.get ? edgeDataSource.get(edgeId) : edgeDataSource.find(e => e.id === edgeId);
            const fromNode = nodeDataSource.get ? nodeDataSource.get(edge.from) : nodeDataSource.find(n => n.id === edge.from);
            const toNode = nodeDataSource.get ? nodeDataSource.get(edge.to) : nodeDataSource.find(n => n.id === edge.to);

            if (edge) {
                let propertiesList = '';
                if (edge.properties && Object.keys(edge.properties).length > 0) {
                    propertiesList += '<div><strong>Properties:</strong><ul>';
                    for (const [key, value] of Object.entries(edge.properties)) {
                        const displayValue = Array.isArray(value) ? value.join(', ') : value;
                        propertiesList += `<li><strong>${key}:</strong> ${displayValue}</li>`;
                    }
                    propertiesList += '</ul></div>';
                }

                content = `
                    <p><strong>Relationship:</strong> ${edge.label || 'related to'}</p>
                    <p><strong>From:</strong> ${fromNode ? fromNode.label : 'N/A'}</p>
                    <p><strong>To:</strong> ${toNode ? toNode.label : 'N/A'}</p>
                    <p><strong>Description:</strong> ${edge.description || 'No description available.'}</p>
                    ${propertiesList}
                `;
            }
        }

        if (content) {
            detailsPopupContent.innerHTML = content;
            const popupWidth = detailsPopup.offsetWidth;
            const popupHeight = detailsPopup.offsetHeight;
            const containerWidth = container.offsetWidth;
            const containerHeight = container.offsetHeight;
            let top = params.pointer.DOM.y + 15;
            let left = params.pointer.DOM.x + 15;
            if (left + popupWidth > containerWidth) {
                left = params.pointer.DOM.x - popupWidth - 15;
            }
            if (top + popupHeight > containerHeight) {
                top = params.pointer.DOM.y - popupHeight - 15;
            }
            detailsPopup.style.top = `${top}px`;
            detailsPopup.style.left = `${left}px`;
            detailsPopup.style.display = 'block';
        }
    });
  }

  function downloadLayout() {
    if (!network || network.body.data.nodes.length === 0) {
        showCustomAlert("No graph is loaded to save a layout.");
        return;
    }

    network.storePositions();
    const nodesToSave = network.body.data.nodes.get({
        fields: ['id', 'x', 'y', 'label', 'description', 'group', 'physics', 'properties', 'labels']
    });
    const edgesToSave = network.body.data.edges.get();
    const graphToSave = { nodes: nodesToSave, edges: edgesToSave };
    const blob = new Blob([JSON.stringify(graphToSave, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "ontology-layout.json";
    a.click();
    URL.revokeObjectURL(url);
  }

  function updateDisplayedGraph(nodesToShow, edgesToShow) {
      network.setData({
          nodes: new vis.DataSet(nodesToShow),
          edges: new vis.DataSet(edgesToShow)
      });
      
  }

  function updateNodeCountDisplay(nodes) {
    const countDisplay = document.getElementById('node-count-display');
    if (!nodes || nodes.length === 0) {
        countDisplay.innerHTML = 'No nodes to display.';
        return;
    }

    const counts = {};
    nodes.forEach(node => {
        const type = node.group || 'Undefined';
        counts[type] = (counts[type] || 0) + 1;
    });

    let html = '<strong>Selected Nodes:</strong><br>';
    Object.entries(counts).sort((a,b) => a[0].localeCompare(b[0])).forEach(([type, count]) => {
        html += `${type}: ${count}<br>`;
    });
    countDisplay.innerHTML = html;
  }

  let filterTimeout;
  function triggerAdvancedFilter() {
      $('#elasticSearchInput').val('');
      applyAllFilters();
  }

  function applyAllFilters() {
      clearTimeout(filterTimeout);
      filterTimeout = setTimeout(() => {
        const liveSearchTerm = $('#elasticSearchInput').val().trim();
        
        const advancedSearchState = { active: false, filters: {} };
        const selectedTypes = new Set();
        $('#node-type-filter-container .form-check-input:checked').each(function() {
            selectedTypes.add($(this).val());
        });
        if ($('#node-type-filter-container .form-check-input').length > 0 && $('#node-type-filter-container .form-check-input').length !== selectedTypes.size) {
            advancedSearchState.active = true;
        }
        $('.active-filters-container').each(function() {
            const pills = $(this).find('.filter-pill');
            if (pills.length > 0) {
                advancedSearchState.active = true;
                const nodeType = $(this).data('type');
                if (!advancedSearchState.filters[nodeType]) {
                    advancedSearchState.filters[nodeType] = [];
                }
                pills.each(function() {
                    advancedSearchState.filters[nodeType].push({
                        prop: $(this).data('prop'),
                        value: $(this).data('value')
                    });
                });
            }
        });

        const isDepthActive = depthFilterState.active;
        const isAdvancedActive = advancedSearchState.active;

        $('#live-search-active-indicator, #clear-live-search').toggle(!!liveSearchTerm && !isDepthActive && !isAdvancedActive);
        $('#depth-filter-active-indicator, #clear-depth-filter').toggle(isDepthActive);
        $('#advanced-search-active-indicator, #clear-advanced-search').toggle(isAdvancedActive);

        // This variable will hold the FULL list of matching nodes
        let filteredNodes; 

        if (isDepthActive || isAdvancedActive) {
            filteredNodes = fullGraph.nodes.filter(node => {
                if (isDepthActive && !depthFilterState.nodeIds.has(node.id)) {
                    return false;
                }

                if (isAdvancedActive) {
                    // --- START: MODIFIED NODE TYPE LOGIC ---
                    const nodeTypeLogic = $('input[name="node-type-logic"]:checked').val();
                    
                    // --- START: FIX FOR "DESELECT ALL" ---
                    const totalTypes = $('#node-type-filter-container .form-check-input').length;
                    if (selectedTypes.size === 0 && totalTypes > 0) {
                        return false; 
                    }
                    // --- END: FIX FOR "DESELECT ALL" ---

                    if (selectedTypes.size > 0) { // Only apply logic if types are selected
                        if (nodeTypeLogic === 'OR') {
                            // OR logic (original): node must have at least ONE selected label
                            const hasSelectedType = node.labels.some(label => selectedTypes.has(label));
                            if (!hasSelectedType) return false;
                        } else {
                            // AND logic (new): node must have ALL selected labels
                            const matchesAllSelectedTypes = Array.from(selectedTypes).every(label => node.labels.includes(label));
                            if (!matchesAllSelectedTypes) return false;
                        }
                    }
                    // --- END: MODIFIED NODE TYPE LOGIC ---

                    const relevantFilters = node.labels.flatMap(label => advancedSearchState.filters[label] || []);
                    
                    if (relevantFilters.length > 0) {
                        const matchesAnyRelevantFilter = relevantFilters.some(filter => {
                            const filterValue = String(filter.value).toLowerCase();
                            if (filter.prop === '__node_contains__') {
                                const queryWords = filterValue.split(/\s+/).filter(w => w.length > 0);
                                const searchGroups = queryWords.map(word => {
                                    const terms = synonymDict[word] ? new Set(synonymDict[word]) : new Set([word]);
                                    return Array.from(terms);
                                });
                                const nodeText = [
                                    node.label,
                                    node.description,
                                    ...(node.properties ? Object.values(node.properties).map(v => Array.isArray(v) ? v.join(' ') : v) : [])
                                ].join(' ').toLowerCase();
                                if (!nodeText) return false;
                                return searchGroups.every(group => {
                                    return group.some(term => {
                                        return nodeText.includes(term);
                                    });
                                });
                            } else if (filter.prop === '__name_is__') {
                                return node.label.toLowerCase() === filterValue;
                            } else {
                                const nodePropValue = node.properties[filter.prop];
                                if (nodePropValue === undefined) return false;
                                const nodeValues = (Array.isArray(nodePropValue) ? nodePropValue : [nodePropValue]).map(v => String(v).toLowerCase());
                                return nodeValues.some(nodeValue => nodeValue.includes(filterValue));
                            }
                        });
                        if (!matchesAnyRelevantFilter) return false;
                    }
                }
                
                return true;
            });
        } 
        else if (liveSearchTerm) {
            filteredNodes = fullGraph.nodes.filter(node => {
                const queryWords = liveSearchTerm.toLowerCase().split(/\s+/).filter(w => w.length > 0);
                const searchGroups = queryWords.map(word => {
                    const terms = synonymDict[word] ? new Set(synonymDict[word]) : new Set([word]);
                    return Array.from(terms);
                });
                const nodeText = [
                    node.label,
                    node.description,
                    ...(node.properties ? Object.values(node.properties).map(v => Array.isArray(v) ? v.join(' ') : v) : [])
                ].join(' ').toLowerCase();
                if (!nodeText) return false;
                return searchGroups.every(group => {
                    return group.some(term => {
                        return nodeText.includes(term);
                    });
                });
            });
        }
        else {
            // No filters are active, so the full list is the entire graph
            filteredNodes = fullGraph.nodes;
        }

        // --- START: NEW DISPLAY & LIMIT LOGIC ---

        // 1. Update the count box with the FULL filtered list
        //    (This solves Problem 2)
        updateNodeCountDisplay(filteredNodes);

        // 2. Create the limited list for visual display
        let nodesToDisplay;
        if (filteredNodes.length > NODE_LIMIT) {
            if (!hasShownNodeLimitWarning) {
                limitModal.show();
                hasShownNodeLimitWarning = true;
            }
            // Get the first 500 nodes from the full list
            nodesToDisplay = filteredNodes.slice(0, NODE_LIMIT);
        } else {
            nodesToDisplay = filteredNodes;
        }

        // 3. Build and render the visual graph using the LIMITED list
        //    (This solves Problem 1)
        const nodeIdsToShow = new Set(nodesToDisplay.map(n => n.id));
        const edgesToShow = fullGraph.edges.filter(edge =>
            nodeIdsToShow.has(edge.from) && nodeIdsToShow.has(edge.to)
        );
        
        // This function now *only* draws the graph
        updateDisplayedGraph(nodesToDisplay, edgesToShow); 
        
        // --- END: NEW DISPLAY & LIMIT LOGIC ---

      }, 300);
  }

  function activateDepthFilter() {
    let startNodes = $('#nodeSelect').val();
    if (startNodes) {
        startNodes = startNodes.filter(id => id && id.length > 0);
    }
    if ((!startNodes || startNodes.length === 0) && network) {
        startNodes = network.getSelectedNodes();
    }
    if (!startNodes || startNodes.length === 0) {
      showCustomAlert("Please select at least one starting node from the list or by clicking on the graph.");
      return;
    }
    const maxDepth = parseInt(document.getElementById('depthInput').value, 10);
    if (isNaN(maxDepth) || maxDepth < 0) {
      showCustomAlert("Please enter a valid, non-negative depth.");
      return;
    }
    
    depthFilterState.active = true;
    depthFilterState.nodeIds.clear();
    startNodes.forEach(id => depthFilterState.nodeIds.add(id));

    let currentLevel = [...startNodes];
    for (let i=0; i < maxDepth; i++) {
        const nextLevel = [];
        currentLevel.forEach(nodeId => {
            fullGraph.edges.forEach(edge => {
                if(edge.from === nodeId && !depthFilterState.nodeIds.has(edge.to)) {
                    depthFilterState.nodeIds.add(edge.to);
                    nextLevel.push(edge.to);
                } else if (edge.to === nodeId && !depthFilterState.nodeIds.has(edge.from)) {
                    depthFilterState.nodeIds.add(edge.from);
                    nextLevel.push(edge.from);
                }
            });
        });
        currentLevel = nextLevel;
    }

    triggerAdvancedFilter();
  }

  function findShortestPath(from, to) {
      const adj = new Map();
      fullGraph.nodes.forEach(node => adj.set(node.id, []));
      fullGraph.edges.forEach(edge => {
          if (adj.has(edge.from) && adj.has(edge.to)) {
              adj.get(edge.from).push(edge.to);
              adj.get(edge.to).push(edge.from);
          }
      });
      const queue = [[from, [from]]];
      const visited = new Set([from]);
      while (queue.length > 0) {
          const [currentNode, path] = queue.shift();
          if (currentNode === to) return path;
          const neighbors = adj.get(currentNode) || [];
          for (const neighbor of neighbors) {
              if (!visited.has(neighbor)) {
                  visited.add(neighbor);
                  const newPath = [...path, neighbor];
                  queue.push([neighbor, newPath]);
              }
          }
      }
      return null;
  }

  function showRelationshipPath() {
    const fromNodeId = $('#pathFromNodeSelect').val();
    const toNodeId = $('#pathToNodeSelect').val();
    if (!fromNodeId || !toNodeId) {
      showCustomAlert("Please select both a 'From' and a 'To' node.");
      return;
    }
    if (fromNodeId === toNodeId) {
      showCustomAlert("'From' and 'To' nodes cannot be the same.");
      return;
    }
    const shortestPath = findShortestPath(fromNodeId, toNodeId);
    if (!shortestPath) {
      showCustomAlert(`No path found between the selected nodes.`);
      return;
    }
    const nodesInPath = new Set(shortestPath);
    const filteredNodes = fullGraph.nodes.filter(n => nodesInPath.has(n.id));
    const filteredEdges = fullGraph.edges.filter(e => {
        const fromInPath = nodesInPath.has(e.from);
        const toInPath = nodesInPath.has(e.to);
        if (fromInPath && toInPath) {
            for(let i = 0; i < shortestPath.length - 1; i++) {
                if ((shortestPath[i] === e.from && shortestPath[i+1] === e.to) || (shortestPath[i] === e.to && shortestPath[i+1] === e.from)) {
                    return true;
                }
            }
        }
        return false;
    });
    updateDisplayedGraph(filteredNodes, filteredEdges);
  }

  function clearLiveSearch() {
    $('#elasticSearchInput').val('');
    applyAllFilters();
  }
  
  function clearDepthFilter() {
    depthFilterState.active = false;
    depthFilterState.nodeIds.clear();
    $('#nodeSelect').val(null).trigger('change');
    $('#depthInput').val(1);
    applyAllFilters();
  }

  function clearAdvancedSearch() {
    $('#node-type-filter-container .form-check-input').prop('checked', true);
    $('.active-filters-container').empty();
    $('.property-filter-container').hide();
    applyAllFilters();
  }

  function resetView() {
    if (!network) return;
    $('#elasticSearchInput').val('');
    depthFilterState.active = false;
    depthFilterState.nodeIds.clear();
    $('#nodeSelect').val(null).trigger('change');
    $('#depthInput').val(1);
    $('#node-type-filter-container .form-check-input').prop('checked', true);
    $('.active-filters-container').empty();
    $('.property-filter-container').hide();
    
    clearQueryBuilder();
    
    applyAllFilters();
    
    network.once('stabilizationIterationsDone', function () {
        network.fit();
    });
  }

  function handleClustering() {
    if (!network || fullGraph.nodes.length === 0) return;

    if (document.getElementById('clusterToggle').checked) {
        if (fullGraph.nodes.length > 200) {
            const clusterOptions = {
                joinCondition: function(nodeOptions) {
                    return nodeOptions.group === this.group;
                },
                clusterNodeProperties: {
                    shape: 'diamond', color: '#FFA500', label: 'Cluster', allowSingleNodeCluster: true
                }
            };
            network.cluster(clusterOptions);
        }
    } else {
        const clusterNodeIds = network.body.data.nodes.getIds({
            filter: function(node) {
                return network.isCluster(node.id);
            }
        });
        clusterNodeIds.forEach(clusterId => {
            network.openCluster(clusterId);
        });
    }
  }

  const aiChatWindow = document.getElementById('ai-chat-window');
  const aiChatInput = document.getElementById('ai-chat-input');

  function renderChatHistory() {
      aiChatWindow.innerHTML = '';
      aiChatHistory.forEach(message => {
          const messageDiv = document.createElement('div');
          messageDiv.classList.add('chat-message');
          messageDiv.classList.add(message.role === 'user' ? 'user-message' : 'ai-message');
          messageDiv.innerText = message.parts[0].text;
          aiChatWindow.appendChild(messageDiv);
      });
      aiChatWindow.scrollTop = aiChatWindow.scrollHeight;
  }

  function generateFullGraphDataForAI() {
    if (fullGraph.nodes.length === 0) return "No graph data is loaded.";

    let context = "This is the full knowledge graph data:\n\n";
    
    context += "NODES:\n";
    fullGraph.nodes.forEach(node => {
        let properties = Object.entries(node.properties)
            .map(([key, value]) => `${key}: "${value}"`)
            .join(', ');
        context += `- (label: "${node.label}", type: ${node.group}, properties: {${properties}});\n`;
    });

    context += "\nRELATIONSHIPS:\n";
    fullGraph.edges.forEach(edge => {
        const fromNode = fullGraph.nodes.find(n => n.id === edge.from);
        const toNode = fullGraph.nodes.find(n => n.id === edge.to);
        if (fromNode && toNode) {
            context += `- ("${fromNode.label}") -[:${edge.label}]-> ("${toNode.label}");\n`;
        }
    });

    return context;
  }

// --- START: NEW HYBRID AI CHAT FUNCTION ---
  async function askAIChat() {
    const question = aiChatInput.value.trim();
    if (!question) return;

    // 1. Add user message and spinner
    aiChatHistory.push({ role: 'user', parts: [{ text: question }] });
    renderChatHistory();
    aiChatInput.value = '';

    const loadingSpinner = document.createElement('div');
    loadingSpinner.classList.add('loading-spinner');
    loadingSpinner.style.display = 'block';
    aiChatWindow.appendChild(loadingSpinner);
    aiChatWindow.scrollTop = aiChatWindow.scrollHeight;

    try {
        let answer = ""; // Define answer variable
        
        // --- THIS IS THE NEW HYBRID LOGIC ---
        if (currentDataSourceMode === 'database') {
            // --- PATH 1: DATABASE MODE (Use Backend for Cypher RAG) ---
            console.log("Asking AI via backend (Database Mode)...");
            const response = await fetch('http://localhost:3000/api/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question: question })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Server responded with status: ${response.status}`);
            }
            const result = await response.json();
            answer = result.answer;

        } else if (currentDataSourceMode === 'file') {
            // --- PATH 2: FILE MODE (Use Frontend for Full-Context Query) ---
            console.log("Asking AI via frontend (File Mode)...");
            
            // Check for the API key (using the OLD placeholder as the check)
            if (!GEMINI_API_KEY || GEMINI_API_KEY.startsWith("AIzaSyANGL")) { 
                throw new Error("No valid Gemini API key is configured in the frontend HTML script. Please update the 'GEMINI_API_KEY' variable around line 728.");
            }
            
            // Check for data
            if (fullGraph.nodes.length === 0) {
                throw new Error("Please load an ontology from a file first.");
            }

            const graphData = generateFullGraphDataForAI(); 
            const prompt = `You are an ontology assistant. Based ONLY on the knowledge graph data provided below, answer the user's question. The data describes nodes and their relationships.\n\n--- KNOWLEDGE GRAPH DATA ---\n${graphData}\n--- END DATA ---\n\nUSER QUESTION: "${question}"`;

            // Use the 2.0-flash model to match your backend
            const geminiResponse = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { "temperature": 0.0 }
                })
            });

            if (!geminiResponse.ok) {
                const errorData = await geminiResponse.json();
                throw new Error(errorData.error?.message || `Gemini API responded with status: ${geminiResponse.status}`);
            }
            
            const result = await geminiResponse.json();
            answer = result.candidates[0]?.content?.parts[0]?.text || "The AI returned an empty response.";
        
        } else {
            // --- PATH 3: NO DATA LOADED ---
             throw new Error("Please load an ontology from a file or database first.");
        }
        // --- END OF HYBRID LOGIC ---

        aiChatHistory.push({ role: 'model', parts: [{ text: answer }]});

    } catch (error) {
        // --- GENERIC ERROR HANDLER ---
        console.error("Error in askAIChat:", error);
        const errorMessage = `Sorry, I couldn't get a response. Error: ${error.message}`;
        aiChatHistory.push({ role: 'model', parts: [{ text: errorMessage }]});
    
    } finally {
        // Always remove the spinner and re-render
        const spinner = aiChatWindow.querySelector('.loading-spinner');
        if (spinner) aiChatWindow.removeChild(spinner);
        renderChatHistory();
    }
  }
  // --- END: NEW HYBRID AI CHAT FUNCTION ---

  async function loadFromNeo4j() {
      document.getElementById('file-name-display').innerText = `(Loading from Database...)`;
      hasShownNodeLimitWarning = false; // Reset warning on new data load
      try {
        const response = await fetch('http://localhost:3000/api/graph', { method: 'POST', headers: { 'Content-Type': 'application/json' } });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Failed to fetch from server: ${response.status}. ${errorText}`);
        }
        const graphData = await response.json();
        isDbConnected = true; // Set flag on successful DB load
        
        cachedSchemaGraph = null;
        console.log("Database reloaded. Schema cache invalidated.");

        processAndRenderGraph(graphData, "Neo4j Database");
        resetOntologyLoadButtons();
        $('#btnLoadFromDb').removeClass('btn-secondary').addClass('btn-success');
        updateUIMode('database'); // <-- Set mode to database
        
        return true; // <-- ADD THIS LINE

      } catch(err) {
        showCustomAlert("It looks like the data base connection is not active, please use another method to load your Ontology", "Connection Error");
        document.getElementById('file-name-display').innerText = ``;
        console.error(err);
        updateUIMode('none');
        
        return false; // <-- ADD THIS LINE
      }
    }
    async function loadOntologyFromUrl(ontologyUrl, ontologyName) {
      document.getElementById('file-name-display').innerText = `(Loading ${ontologyName} from file...)`;
      hasShownNodeLimitWarning = false;
      
      try {
          const response = await fetch(ontologyUrl);
          if (!response.ok) {
              throw new Error(`Failed to fetch file: ${response.statusText}`);
          }
          const graphData = await response.json();
          
          isDbConnected = false;
          processAndRenderGraph(graphData, ontologyName);
          
          resetOntologyLoadButtons(); 
          // Find the option by its text content and select it
          $("#fileOntologySelector option").filter(function() {
              return $(this).text() === ontologyName;
          }).prop('selected', true);
          
          updateUIMode('file'); // Set mode to file
          return true; // Success
      } catch(err) {
          showCustomAlert(`Error loading or parsing the ontology file: ${err.message}`, "File Error");
          document.getElementById('file-name-display').innerText = ``;
          console.error(err);
          updateUIMode('none');
          return false; // Failure
      }
    } 
  // --- START: NEW FUNCTION to load from configured file ---
  async function loadOntologyFromFile() {
    const selectedOption = $('#fileOntologySelector option:selected');
    const ontologyUrl = selectedOption.data('url');
    const ontologyName = selectedOption.text();

    if (!ontologyUrl) {
        showCustomAlert("Please select a configured ontology to load.", "No Ontology Selected");
        return;
    }

    document.getElementById('file-name-display').innerText = `(Loading ${ontologyName} from file...)`;
    hasShownNodeLimitWarning = false;
    
    try {
        const response = await fetch(ontologyUrl);
        if (!response.ok) {
            throw new Error(`Failed to fetch file: ${response.statusText}`);
        }
        const graphData = await response.json();
        
        isDbConnected = false;
        processAndRenderGraph(graphData, ontologyName);
        
        resetOntologyLoadButtons(); // Visually reset buttons
        $('#fileOntologySelector').addClass('is-valid'); // Add a visual cue
        updateUIMode('file'); // <-- Set mode to file

    } catch(err) {
        showCustomAlert(`Error loading or parsing the ontology file: ${err.message}`, "File Error");
        document.getElementById('file-name-display').innerText = ``;
        console.error(err);
        updateUIMode('none');
    }
  }
  // --- END: NEW FUNCTION to load from configured file ---

  function processAndRenderGraph(graph, sourceName) {
    try {
        if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(graph.edges)) {
            throw new Error("Input data is not a valid graph object.");
        }
        document.getElementById('file-name-display').innerText = `(Source: ${sourceName})`;

        if (sourceName !== "Neo4j Database") {
            isDbConnected = false; 
        }

        const newOptions = buildOptions();
        network.setOptions(newOptions);
        
        const allNodeLabels = new Set();
        graph.nodes.forEach(n => {
            if (n.labels && Array.isArray(n.labels)) {
                n.labels.forEach(label => allNodeLabels.add(label));
            }
            if (n.group) {
                allNodeLabels.add(n.group);
            }
        });

        const dynamicGroups = {};
        const pastelColors = ['#a8e6cf', '#dcedc1', '#ffd3b6', '#ffaaa5', '#ff8b94', '#b8a9c9', '#f6eac2', '#b2d8d8', '#ffc0cb', '#fde2e4'];
        let colorIndex = 0;
        Array.from(allNodeLabels).sort().forEach(label => {
            if (!dynamicGroups[label]) {
                dynamicGroups[label] = { color: { background: pastelColors[colorIndex % pastelColors.length], border: '#555' }, font: { color: '#000' } };
                colorIndex++;
            }
        });

        typeProperties = {};
        const processedNodes = graph.nodes.map(n => {
            let properties = (n.properties || n.Properties) && typeof (n.properties || n.Properties) === 'object' ? (n.properties || n.Properties) : {};
            const nodeLabels = (n.labels && n.labels.length > 0) ? n.labels : [n.group || "Undefined"];
            const group = n.group || nodeLabels[0]; 

            nodeLabels.forEach(label => {
                if (!typeProperties[label]) typeProperties[label] = new Set();
                Object.keys(properties).forEach(prop => typeProperties[label].add(prop));
            });
            return { ...n, properties: properties, labels: nodeLabels, group: group };
        });
        
        const validNodeIds = new Set(processedNodes.map(n => n.id));
        const missingEdgeNodes = new Set();

        const validEdges = graph.edges.filter(e => {
            const fromExists = validNodeIds.has(e.from);
            const toExists = validNodeIds.has(e.to);
            if (!fromExists) missingEdgeNodes.add(e.from);
            if (!toExists) missingEdgeNodes.add(e.to);
            return fromExists && toExists;
        });

        if (missingEdgeNodes.size > 0) {
            const missingNodesList = Array.from(missingEdgeNodes).join(', ');
            showCustomAlert(`The following nodes mentioned in edges were not found in the nodes definition and have been ignored: ${missingNodesList}`, "Missing Nodes Warning");
        }

        fullGraph = {
          nodes: processedNodes,
          edges: validEdges.map((e, index) => ({
            id: e.id || `${e.from}-${e.to}-${index}`,
            from: e.from, to: e.to, label: e.label, arrows: "to",
            description: e.description || "", properties: e.properties || {}
          }))
        };

        if (fullGraph.nodes.length > NODE_LIMIT && !hasShownNodeLimitWarning) {
            if (limitModal) limitModal.show();
            hasShownNodeLimitWarning = true;
        }

        network.setOptions({ groups: dynamicGroups });

        const $typeFilterContainer = $('#node-type-filter-container');
        $typeFilterContainer.empty();
        const nodeTypes = Array.from(allNodeLabels).sort();
        nodeTypes.forEach(type => {
            const color = dynamicGroups[type].color.background;
            const itemHtml = `
                <div class="node-type-filter-item mb-2">
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="${type}" id="type-check-${type}" checked onchange="triggerAdvancedFilter()">
                            <label class="form-check-label" for="type-check-${type}">${type}</label>
                        </div>
                        <div class="d-flex align-items-center">
                            <span class="color-box" style="background-color: ${color};"></span>
                            <a href="#" class="property-toggle-arrow" data-type="${type}">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>
                            </a>
                        </div>
                    </div>
                    <div class="property-filter-container" data-type="${type}" style="display: none;">
                        <div class="active-filters-container mb-2" data-type="${type}"></div>
                        <div class="input-group input-group-sm mb-2">
                            <select class="property-select form-select"><option value="">-- Select Property --</option></select>
                            <input type="text" class="property-value-input form-control" placeholder="Value...">
                            <button class="btn btn-outline-secondary add-filter-btn" type="button">+</button>
                        </div>
                        <div class="input-group input-group-sm mb-2">
                            <span class="input-group-text" style="font-size: .75rem;">Node contains</span>
                            <input type="text" class="node-contains-value-input form-control" placeholder="Text...">
                            <button class="btn btn-outline-secondary add-node-contains-filter-btn" type="button">+</button>
                        </div>
                        <div class="input-group input-group-sm">
                            <span class="input-group-text" style="font-size: .75rem;">Name is</span>
                            <input type="text" class="name-is-value-input form-control" placeholder="Exact Text...">
                            <button class="btn btn-outline-secondary add-name-is-filter-btn" type="button">+</button>
                        </div>
                    </div>
                </div>`;
            $typeFilterContainer.append(itemHtml);
        });

        $('.add-filter-btn').on('click', handleAddPropertyFilter);
        $('.add-node-contains-filter-btn').on('click', handleAddNodeContainsFilter);
        $('.add-name-is-filter-btn').on('click', handleAddNameIsFilter);
        $typeFilterContainer.on('click', '.remove-filter', handleRemoveFilter);

        const typeOptions = '<option value="">-- Select Type --</option>' + nodeTypes.map(type => `<option value="${type}">${type}</option>`).join('');
        $('#pathFromTypeSelect, #pathToTypeSelect').html(typeOptions);

        const allNodeOptions = fullGraph.nodes.sort((a,b) => (a.label || '').localeCompare(b.label || '')).map(n => `<option value="${n.id}">${n.label}</option>`).join('');
        $('#nodeSelect').html(allNodeOptions).val(null).trigger('change');
        
        $('#pathFromTypeSelect, #pathToTypeSelect').val('');
        populateNodeDropdown(null, $('#pathFromNodeSelect'));
        populateNodeDropdown(null, $('#pathToNodeSelect'));

        aiChatHistory = [];
        aiChatWindow.innerHTML = '<div class="ai-message">Ask a question about the loaded data...</div>';

        resetView();
        document.getElementById('uploadLayout').value = '';

        handleClustering();

      } catch (err) {
        showCustomAlert("Invalid data format received.");
        console.error("Error in processAndRenderGraph:", err);
      }
  }

  document.getElementById("uploadOntology").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      hasShownNodeLimitWarning = false;
      try {
        let fileContent = e.target.result;
        let fixedContent = fileContent.replace(/,\s*([}\]])/g, "$1");
        const graph = JSON.parse(fixedContent);
        if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(graph.edges)) {
            throw new Error("Invalid JSON format. Missing 'nodes' or 'edges' array.");
        }
        const fileNameWithoutExt = file.name.split('.').slice(0, -1).join('.') || file.name;
        isDbConnected = false;
        processAndRenderGraph(graph, fileNameWithoutExt);
        resetOntologyLoadButtons();
        $('#btnLoadOntology').removeClass('btn-secondary').addClass('btn-success').text(file.name);
        updateUIMode('file');
      } catch (err) {
        console.error("Failed to parse JSON:", err);
        showCustomAlert("The file does not appear to be valid JSON. Please check that it contains both 'nodes' and 'edges' arrays.", "JSON Parse Error");
      }
    };
    reader.readAsText(file);
  });
  
  function processSynonyms(synonymData) {
    synonymDict = {}; // Clear existing dictionary
    for (const key in synonymData) {
        if (Array.isArray(synonymData[key])) {
            const allSynonyms = new Set([key.toLowerCase(), ...synonymData[key].map(s => String(s).toLowerCase())]);
            allSynonyms.forEach(word => {
                synonymDict[word] = Array.from(allSynonyms);
            });
        }
    }
  }
    async function loadSynonymsFromUrl(url) {
      const $btn = $('#btnLoadSynonyms'); // Get the button for feedback
      try {
          const response = await fetch(url);
          if (!response.ok) {
              throw new Error(`File not found or network error (status: ${response.status})`);
          }
          const synonyms = await response.json();
          if (typeof synonyms !== 'object' || synonyms === null || Array.isArray(synonyms)) {
              throw new Error("Invalid JSON format. Expected a key-value object.");
          }
          
          processSynonyms(synonyms); // Use the existing processor
          
          // Provide success feedback on the button
          $btn.removeClass('btn-secondary').addClass('btn-success').text('Synonyms Loaded (default)');
          console.log("Successfully loaded default synonyms from:", url);
          
      } catch (err) {
          // Provide failure feedback on the button
          console.error("Failed to auto-load synonyms:", err.message);
          $btn.removeClass('btn-success').addClass('btn-warning').text('Failed to load synonyms');
      }
  }
  
  document.getElementById("uploadSynonyms").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      try {
        const synonyms = JSON.parse(e.target.result);
        if (typeof synonyms !== 'object' || synonyms === null || Array.isArray(synonyms)) {
            throw new Error("Invalid JSON format. Expected a key-value object.");
        }
        processSynonyms(synonyms);
        $('#btnLoadSynonyms').removeClass('btn-secondary').addClass('btn-success').text(file.name);
      } catch (err) {
        console.error("Failed to parse synonym JSON:", err);
        showCustomAlert("The synonym file does not appear to be a valid JSON object.", "JSON Parse Error");
      }
    };
    reader.readAsText(file);
  });

  document.getElementById("uploadLayout").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      hasShownNodeLimitWarning = false;
      try {
        let fileContent = e.target.result;
        let fixedContent = fileContent.replace(/,\s*([}\]])/g, "$1");
        const graphData = JSON.parse(fixedContent);
        if (!graphData || !Array.isArray(graphData.nodes)) {
             throw new Error("Layout file must contain a 'nodes' array.");
        }
        if (!Array.isArray(graphData.edges)) {
            graphData.edges = []; 
        }
        isDbConnected = false;
        processAndRenderGraph(graphData, file.name);
        resetOntologyLoadButtons();
        $('#btnLoadLayout').removeClass('btn-secondary').addClass('btn-success').text(file.name);
        updateUIMode('file');
      } catch (err) {
        console.error("Failed to parse JSON:", err);
        showCustomAlert("The file does not appear to be valid JSON. Please check that it contains a 'nodes' array.", "JSON Parse Error");
      } finally {
        event.target.value = '';
      }
    };
    reader.readAsText(file);
  });

  document.getElementById("uploadCypher").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      hasShownNodeLimitWarning = false;
      try {
        const cypherText = e.target.result;
        const graph = parseCypher(cypherText);
        if (graph.nodes.length === 0 && graph.edges.length === 0) {
            throw new Error("Cypher file did not produce any nodes or edges.");
        }
        const fileNameWithoutExt = file.name.split('.').slice(0, -1).join('.') || file.name;
        isDbConnected = false;
        processAndRenderGraph(graph, fileNameWithoutExt);
        resetOntologyLoadButtons();
        $('#btnLoadCypher').removeClass('btn-secondary').addClass('btn-success').text(file.name);
        updateUIMode('file');
      } catch (err) {
        showCustomAlert("The file uploaded does not follow the format required, please check and try again");
        console.error(err);
      }
    };
    reader.readAsText(file);
  });

  document.getElementById("uploadOwl").addEventListener("change", function (event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (e) {
      hasShownNodeLimitWarning = false;
      try {
        const fileContent = e.target.result;
        let graph;

        if (fileContent.trim().match(/^@prefix|@base/i)) {
          graph = parseTurtle(fileContent);
        } else {
          graph = parseOwl(fileContent);
        }

        if (graph.nodes.length === 0) {
            throw new Error("The parser did not produce any nodes from the file.");
        }
        const fileNameWithoutExt = file.name.split('.').slice(0, -1).join('.') || file.name;
        isDbConnected = false;
        processAndRenderGraph(graph, fileNameWithoutExt);
        resetOntologyLoadButtons();
        $('#btnLoadOwl').removeClass('btn-secondary').addClass('btn-success').text(file.name);
        updateUIMode('file');
      } catch (err) {
        showCustomAlert("The file format is not a valid or supported OWL (RDF/XML or Turtle) format. Please check and try again.", "Parsing Error");
        console.error(err);
      }
    };
    reader.readAsText(file);
  });

  function parseTurtle(fileContent) {
    const prefixes = {};
    const nodes = new Map();
    const edges = [];
    
    const directiveRegex = /@(\w+)\s+(.*?)\s*\./g;
    let match;
    while ((match = directiveRegex.exec(fileContent)) !== null) {
      if (match[1].toLowerCase() === 'prefix') {
        const parts = match[2].trim().split(/\s+/);
        if (parts.length === 2) {
          const prefix = parts[0].slice(0, -1);
          const uri = parts[1].slice(1, -1);
          prefixes[prefix] = uri;
        }
      }
    }
    
    const expandPrefix = (name) => {
        if (!name || !name.includes(':')) return name;
        const [prefix, local] = name.split(':', 2);
        return prefixes[prefix] ? name : name;
    };
    
    const content = fileContent
        .replace(directiveRegex, '')
        .replace(/#.*$/gm, '')
        .trim();

    const subjectBlocks = content.split(/\s\.\s*/).filter(block => block.trim());

    subjectBlocks.forEach(block => {
      const parts = block.trim().split(/\s+/);
      if (parts.length < 3) return;

      const subjectId = expandPrefix(parts[0]);
      if (!nodes.has(subjectId)) {
          nodes.set(subjectId, { id: subjectId, label: subjectId.split(/[:#\/]/).pop(), labels: ["Thing"], properties: {}, description: "" });
      }

      const predicateObjectPairs = block.substring(parts[0].length).trim().split(';');
      
      predicateObjectPairs.forEach(pairStr => {
        const pair = pairStr.trim().split(/\s+/);
        if (pair.length < 2) return;
        
        const predicate = expandPrefix(pair[0]);
        const objectStr = pair.slice(1).join(' ');

        const objects = objectStr.split(',').map(o => o.trim());

        objects.forEach(obj => {
          const subjectNode = nodes.get(subjectId);
          
          if (predicate === 'a' || predicate === 'rdf:type') {
            const type = obj.split(/[:#\/]/).pop();
            if (!subjectNode.labels.includes(type)) {
                if (subjectNode.labels[0] === 'Thing' && type !== 'Thing') {
                    subjectNode.labels = [type];
                } else if (type !== 'Thing') {
                    subjectNode.labels.push(type);
                }
            }
          } else if (obj.startsWith('"')) {
            const literalValue = obj.replace(/^"|"(@[\w-]+)?(\^\^.+)?"$/g, '');
            const propName = predicate.split(/[:#\/]/).pop();
            if (['label', 'title', 'name'].includes(propName.toLowerCase())) {
                subjectNode.label = literalValue;
            } else if (['description', 'comment'].includes(propName.toLowerCase())) {
                subjectNode.description = (subjectNode.description ? subjectNode.description + "\n" : "") + literalValue;
            } else {
                if (subjectNode.properties[propName]) {
                    if (Array.isArray(subjectNode.properties[propName])) {
                        subjectNode.properties[propName].push(literalValue);
                    } else {
                        subjectNode.properties[propName] = [subjectNode.properties[propName], literalValue];
                    }
                } else {
                    subjectNode.properties[propName] = literalValue;
                }
            }
          } else {
            const objectId = expandPrefix(obj);
            if (!nodes.has(objectId)) {
              nodes.set(objectId, { id: objectId, label: objectId.split(/[:#\/]/).pop(), labels: ["Thing"], properties: {}, description: "" });
            }
            edges.push({
              from: subjectId,
              to: objectId,
              label: predicate.split(/[:#\/]/).pop()
            });
          }
        });
      });
    });

    nodes.forEach(node => {
        node.group = node.labels.find(l => l !== 'Class' && l !== 'ObjectProperty' && l !== 'DatatypeProperty') || node.labels[0] || 'Thing';
    });
    
    return { nodes: Array.from(nodes.values()), edges: edges };
  }

  function parseOwl(fileContent) {
    if (fileContent.trim().startsWith("CREATE (n:")) {
        console.warn("The file appears to be a Cypher script, not OWL. Parsing as Cypher.");
        return parseCypher(fileContent);
    }
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(fileContent, "application/xml");
    if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
        const error = xmlDoc.getElementsByTagName("parsererror")[0];
        console.error("XML Parsing Error:", error.textContent);
        throw new Error("Failed to parse XML. Please ensure the file is a valid OWL (RDF/XML) or Cypher script.");
    }
    const nodeMap = new Map();
    const edges = [];
    const ns = { owl: "http://www.w3.org/2002/07/owl#", rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#", rdfs: "http://www.w3.org/2000/01/rdf-schema#" };
    const cleanId = (id) => id.startsWith('#') ? id.substring(1) : id;
    const classes = xmlDoc.getElementsByTagNameNS(ns.owl, "Class");
    for (const cls of classes) {
        const about = cls.getAttributeNS(ns.rdf, "about");
        if (about) {
            const id = cleanId(about);
            if (!nodeMap.has(id)) {
                const labelNode = cls.getElementsByTagNameNS(ns.rdfs, "label")[0];
                const label = labelNode ? labelNode.textContent : id;
                nodeMap.set(id, { id: id, label: label, labels: ["Class"], properties: {} });
            }
        }
    }
    const individuals = xmlDoc.getElementsByTagNameNS(ns.owl, "NamedIndividual");
    for (const ind of individuals) {
        const about = ind.getAttributeNS(ns.rdf, "about");
        if (about) {
            const id = cleanId(about);
            const properties = {};
            const individualLabels = new Set();
            let label = id;
            for (const child of ind.children) {
                if (child.hasAttributeNS(ns.rdf, "resource")) {
                     if (child.namespaceURI === ns.rdf && child.localName === 'type') {
                        const resource = child.getAttributeNS(ns.rdf, "resource");
                        if (resource && resource !== `${ns.owl}NamedIndividual`) individualLabels.add(resource.split('#').pop());
                    }
                } else {
                    const propName = child.localName;
                    const propValue = child.textContent;
                    properties[propName] = propValue;
                    if (propName.toLowerCase() === 'label') label = propValue;
                }
            }
            nodeMap.set(id, { id: id, label: label, labels: individualLabels.size > 0 ? Array.from(individualLabels) : ["Individual"], properties: properties });
        }
    }
    for (const cls of classes) {
        const about = cls.getAttributeNS(ns.rdf, "about");
        if (about) {
            const sourceId = cleanId(about);
            const subClassOfNodes = cls.getElementsByTagNameNS(ns.rdfs, "subClassOf");
            for (const sub of subClassOfNodes) {
                const targetResource = sub.getAttributeNS(ns.rdf, "resource");
                if (targetResource) edges.push({ from: sourceId, to: cleanId(targetResource), label: "subClassOf" });
            }
        }
    }
    for (const ind of individuals) {
        const about = ind.getAttributeNS(ns.rdf, "about");
        if (about) {
            const sourceId = cleanId(about);
            for (const child of ind.children) {
                const resource = child.getAttributeNS(ns.rdf, "resource");
                if (resource && !(child.namespaceURI === ns.rdf && child.localName === 'type')) {
                    edges.push({ from: sourceId, to: cleanId(resource), label: child.localName });
                }
            }
        }
    }
    return { nodes: Array.from(nodeMap.values()), edges: edges };
  }

  function parseCypher(text) {
    const nodes = []; const edges = []; const lines = text.split(';');
    const nodeRegex = /CREATE \(.+?:(.+?) \{(.+?)\}\)/;
    const edgeRegex = /MATCH \(a \{id: "([^"]+)"\}\), \(b \{id: "([^"]+)"\}\) CREATE \(a\)-\[:(.+?) (?:\{(.+?)\})?\]->\(b\)/;
    lines.forEach(line => {
        const trimmedLine = line.trim();
        if (trimmedLine.startsWith('CREATE')) {
            const match = trimmedLine.match(nodeRegex);
            if (match) {
                const labels = match[1].split(':').map(l => l.trim());
                const propsText = match[2]; const properties = {};
                const propRegex = /(\w+):\s*"([^"]*)"/g;
                let propMatch;
                while ((propMatch = propRegex.exec(propsText)) !== null) properties[propMatch[1]] = propMatch[2];
                nodes.push({ id: properties.id, label: properties.label || properties.id, labels: labels, properties: properties, description: properties.description || "" });
            }
        } else if (trimmedLine.startsWith('MATCH')) {
            const match = trimmedLine.match(edgeRegex);
            if (match) {
                const [from, to, label, propsText] = [match[1], match[2], match[3], match[4] || ""];
                const properties = {};
                const propRegex = /(\w+):\s*"([^"]*)"/g;
                let propMatch;
                while ((propMatch = propRegex.exec(propsText)) !== null) properties[propMatch[1]] = propMatch[2];
                edges.push({ from, to, label, description: properties.description || "" });
            }
        }
    });
    return { nodes, edges };
  }

  function populateNodeDropdown(type, $nodeDropdown) {
    if (!type) {
        $nodeDropdown.html('<option value="">-- Select Type First --</option>').prop('disabled', true);
    } else {
        const filteredNodes = fullGraph.nodes.filter(n => n.labels.includes(type)).sort((a,b) => (a.label || '').localeCompare(b.label || ''));
        const options = filteredNodes.map(n => `<option value="${n.id}">${n.label}</option>`).join('');
        $nodeDropdown.html(options).prop('disabled', false);
    }
    $nodeDropdown.val(null).trigger('change.select2');
  }

  function initResizer() {
    const resizer = document.getElementById('resizer');
    const leftPanel = document.getElementById('viewer-container');
    const rightPanel = document.getElementById('sidebar');
    let isResizing = false;
    resizer.addEventListener('mousedown', (e) => {
        isResizing = true;
        document.body.style.cursor = 'col-resize';
        document.body.style.userSelect = 'none';
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', stopResize);
    });
    function handleMouseMove(e) {
        if (!isResizing) return;
        const container = document.getElementById('main-container');
        const [leftPanelMinWidth, rightPanelMinWidth, totalWidth] = [300, 300, container.offsetWidth];
        let newLeftWidth = e.clientX - container.offsetLeft;
        if (newLeftWidth < leftPanelMinWidth) newLeftWidth = leftPanelMinWidth;
        if (totalWidth - newLeftWidth - resizer.offsetWidth < rightPanelMinWidth) newLeftWidth = totalWidth - rightPanelMinWidth - resizer.offsetWidth;
        const [newLeftFlex, newRightFlex] = [newLeftWidth, totalWidth - newLeftWidth - resizer.offsetWidth];
        leftPanel.style.flex = `0 0 ${newLeftFlex}px`;
        rightPanel.style.flex = `1 1 ${newRightFlex}px`;
        if (network) setTimeout(() => network.fit(), 50);
    }
    
  
	function stopResize() {
        isResizing = false;
        document.body.style.cursor = 'default';
        document.body.style.userSelect = 'auto';
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', stopResize);
    }
}
    /**
   * Applies an ontology filter to the graph after it has been loaded.
   * This function assumes the graph is already in 'fullGraph'.
   */
  function applyOntologyFilter(ontologyLabel) {
      // 1. Check if the requested label actually exists in the filter list
      const checkboxId = `#type-check-${ontologyLabel}`;
      if ($(checkboxId).length === 0) {
          // The label doesn't exist. Warn the user and just show the full graph.
          showCustomAlert(`Ontology label "${ontologyLabel}" not found in the loaded graph data. Showing all data instead.`);
          resetView();
          return;
      }

      // 2. Programmatically set the filters
      // First, deselect all node types
      $('#node-type-filter-container .form-check-input').prop('checked', false);
      
      // Second, select *only* the one we want
      $(checkboxId).prop('checked', true);

      // 3. Apply the filter
      // We use a small delay to ensure the UI has time to catch up
      setTimeout(() => {
          triggerAdvancedFilter();
          
          // Update the display text to reflect the filter
          document.getElementById('file-name-display').innerText = `(Source: Neo4j Database | Filtered: ${ontologyLabel})`;
      }, 100); 
    }
	
	/**
   * Loads the entire graph from the DB, then auto-switches to the
   * Analysis tab and applies a filter for the specified ontology label.
   * (Used by buttons on the 'Upload' tab)
   */
  async function loadSpecificOntology(ontologyLabel) {
      // 1. Show a loading message
      document.getElementById('file-name-display').innerText = `(Loading Ontology: ${ontologyLabel}...)`;

      // 2. Load ALL data from the database.
      const success = await loadFromNeo4j();

      // 3. If loading failed, stop. (loadFromNeo4j already showed an alert)
      if (!success) {
          document.getElementById('file-name-display').innerText = `(Load failed)`;
          return;
      }
      
      // 4. Update the button styles
      const clickedBtn = Array.from(document.querySelectorAll('#upload-tab-pane .btn')).find(el => el.textContent.includes(ontologyLabel));
      if(clickedBtn) $(clickedBtn).removeClass('btn-primary').addClass('btn-success');

      // 5. Programmatically switch to the "Analysis" tab
      const analysisTabButton = document.querySelector('#analysis-tab');
      const tab = new bootstrap.Tab(analysisTabButton);
      tab.show();

      // 6. Apply the filter using the new helper function
      applyOntologyFilter(ontologyLabel);
    }
	
	/**
   * Checks the URL for an 'ontology' or 'config' parameter on page load.
   * If found, it automatically loads the correct data and applies filters.
   */
  async function handleUrlParametersOnLoad(configFiles) {
      const urlParams = new URLSearchParams(window.location.search);
      const ontologyLabel = urlParams.get('ontology'); // For DB Label
      const configName = urlParams.get('config');     // For File Name

      if (ontologyLabel) {
          // --- 1. DATABASE (ontology label) FLOW ---
          document.getElementById('file-name-display').innerText = `(Auto-loading Ontology: ${ontologyLabel}...)`;
          const success = await loadFromNeo4j();
          if (!success) {
              document.getElementById('file-name-display').innerText = `(Auto-load failed)`;
              return;
          }
          // The tab will be switched by openTabFromHash()
          applyOntologyFilter(ontologyLabel);

      } else if (configName && configFiles) {
          // --- 2. FILE (config name) FLOW ---
          
          // Find the file URL from the config.json data we loaded
          const fileConfig = configFiles.find(f => f.name === configName);
          
          if (fileConfig) {
              // Found it. Now load it using our new reusable function.
              await loadOntologyFromUrl(fileConfig.url, fileConfig.name);
          } else {
              // Couldn't find a matching name in config.json
              showCustomAlert(`Config Error: Could not find an ontology named "${configName}" in config.json.`);
          }
      }
    }
  function resetOntologyLoadButtons() {
      $('#btnLoadFromDb, #btnLoadOntology, #btnLoadLayout, #btnLoadCypher, #btnLoadOwl, #btnLoadCsv').removeClass('btn-success').addClass('btn-secondary');
      $('#btnLoadOntology').text('Load Ontology JSON');
      $('#btnLoadLayout').text('Load Layout');
      $('#btnLoadCypher').text('Load Cypher File');
      $('#btnLoadOwl').text('Load OWL File');
      $('#btnLoadCsv').text('Upload Using CSV');
      $('#fileOntologySelector').removeClass('is-valid');
  }

  function handleCsvUpload() {
      hasShownNodeLimitWarning = false;
      const [nodesFile, edgesFile] = [document.getElementById('nodesCsvFile').files[0], document.getElementById('edgesCsvFile').files[0]];
      if (!nodesFile || !edgesFile) {
          showCustomAlert("Please select both a nodes and an edges CSV file.");
          return;
      }
      const [reader1, reader2] = [new FileReader(), new FileReader()];
      const promise1 = new Promise(resolve => reader1.onload = e => resolve(e.target.result));
      const promise2 = new Promise(resolve => reader2.onload = e => resolve(e.target.result));
      reader1.readAsText(nodesFile);
      reader2.readAsText(edgesFile);
      Promise.all([promise1, promise2]).then(([nodesCsv, edgesCsv]) => {
          try {
              const nodesData = parseCsv(nodesCsv);
              const edgesData = parseCsv(edgesCsv);
              if (nodesData.length < 2) throw new Error("Nodes CSV must contain a header and at least one data row.");
              
              const nodesHeader = nodesData.shift(); // Remove header row
              const edgesHeader = edgesData.length > 0 ? edgesData.shift() : [];
              
              const labelToIdMap = new Map();

              const nodes = nodesData.map(row => {
                  const nodeId = row[1];
                  const nodeLabel = row[2];

                  // Map the node label to its ID for edge creation
                  if (nodeLabel) {
                    labelToIdMap.set(nodeLabel, nodeId);
                  }

                  // Process Labels/NodeTypes
                  const primaryType = row[0] ? row[0].trim() : '';
                  const additionalTypesRaw = row[3] ? row[3].split(',') : [];
                  const additionalTypes = additionalTypesRaw.map(t => t.trim()).filter(t => t);
                  const allLabels = [...new Set([primaryType, ...additionalTypes].filter(Boolean))];
                  
                  // Process Properties
                  const properties = {};
                  // Properties start from column index 5 onwards
                  for (let i = 5; i < nodesHeader.length; i++) {
                      const propCell = row[i] ? row[i].trim() : '';
                      if (propCell) {
                          const parts = propCell.split(':');
                          const key = parts[0].trim();
                          // Handle cases where the value might contain colons
                          const value = parts.length > 1 ? parts.slice(1).join(':').trim() : '';
                          if (key) {
                              properties[key] = value;
                          }
                      }
                  }

                  return { 
                      id: nodeId, 
                      label: nodeLabel, 
                      labels: allLabels.length > 0 ? allLabels : ['Undefined'], 
                      description: row[4] || '', // Description is at index 4
                      properties: properties 
                  };
              });

              const missingNodeLabels = new Set();
              const edges = edgesData.map(row => {
                  const [fromLabel, toLabel] = [row[0], row[2]];
                  const fromId = labelToIdMap.get(fromLabel);
                  const toId = labelToIdMap.get(toLabel);
                  
                  let edgeIsValid = true;
                  if (!fromId) {
                      missingNodeLabels.add(fromLabel);
                      edgeIsValid = false;
                  }
                  if (!toId) {
                      missingNodeLabels.add(toLabel);
                      edgeIsValid = false;
                  }

                  if (!edgeIsValid) {
                      console.warn(`Could not find nodes for edge: ${fromLabel} -> ${toLabel}`);
                      return null;
                  }

                  const properties = {};
                  for (let i = 4; i < edgesHeader.length; i++) {
                      if (row[i] && row[i].trim()) {
                          properties[edgesHeader[i]] = row[i].trim();
                      }
                  }
                  return { from: fromId, to: toId, label: row[1], description: row[3], properties: properties };
              }).filter(e => e !== null);

              if (missingNodeLabels.size > 0) {
                  const missingNodesList = Array.from(missingNodeLabels).join(', ');
                  showCustomAlert(`The following node labels mentioned in the edges CSV were not found in the nodes CSV and their edges have been ignored: ${missingNodesList}`, "Missing Nodes Warning");
              }
              
              isDbConnected = false;
              processAndRenderGraph({ nodes, edges }, "CSV Files");
              resetOntologyLoadButtons();
              $('#btnLoadCsv').removeClass('btn-secondary').addClass('btn-success');
              csvUploadModal.hide();
              updateUIMode('file');
          } catch (e) {
              showCustomAlert("The file uploaded does not follow the format required, please check and try again. Error: " + e.message);
              console.error(e);
          }
      });
  }

  function parseCsv(csvText) {
      const rows = [];
      const lines = csvText.split('\n');
      lines.forEach(line => {
          if (line.trim() === '') return;
          const row = []; let field = ''; let inQuotes = false;
          for (let i = 0; i < line.length; i++) {
              const char = line[i];
              if (char === '"' && (i === 0 || line[i-1] !== '\\')) inQuotes = !inQuotes;
              else if (char === ',' && !inQuotes) { row.push(field); field = ''; }
              else field += char;
          }
          row.push(field);
          rows.push(row.map(f => f.replace(/^"|"$/g, '').replace(/""/g, '"')));
      });
      return rows;
  }

  function showCustomAlert(message, title = "Alert") {
      document.getElementById('customAlertModalLabel').textContent = title;
      document.getElementById('customAlertModalBody').textContent = message;
      customAlertModal.show();
  }

  function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
  }

  function updateElasticSearchResults() {
      const searchTerm = $('#elasticSearchInput').val().trim().toLowerCase();
      const resultsContainer = $('#elastic-search-results');
      
      if (searchTerm.length < 2) {
          resultsContainer.hide().empty();
          return;
      }

      const matches = new Set();
      const maxResults = 20;

      for (const node of fullGraph.nodes) {
          if (matches.size >= maxResults) break;
          
          const nodeLabel = String(node.label || '').toLowerCase();
          if (nodeLabel.includes(searchTerm)) {
              matches.add(JSON.stringify({ text: node.label, type: node.group }));
          }

          if (node.properties) {
              for (const value of Object.values(node.properties)) {
                  if (matches.size >= maxResults) break;
                  const propValue = String(value || '').toLowerCase();
                  if (propValue.includes(searchTerm)) {
                      matches.add(JSON.stringify({ text: String(value), type: node.group }));
                  }
              }
          }
      }

      if (matches.size === 0) {
          resultsContainer.hide().empty();
          return;
      }

      let resultsHtml = '';
      const safeSearchTerm = escapeRegExp(searchTerm);
      matches.forEach(matchStr => {
          const match = JSON.parse(matchStr);
          const highlightedText = match.text.replace(new RegExp(safeSearchTerm, 'gi'), (match) => `<span class="search-result-match">${match}</span>`);
          // We add data-full-text="${...}" to safely store the original text.
        // We also escape any quotes in the text to prevent breaking the HTML.
        const safeFullText = match.text.replace(/"/g, '&quot;');
        resultsHtml += `<a class="list-group-item list-group-item-action" data-full-text="${safeFullText}">
            ${highlightedText}
            <span class="search-result-nodetype">${match.type}</span>
        </a>`;
      });

      resultsContainer.html(resultsHtml).show();
  }
  
    function updateQueryOutputLabel(partId) {
        const part = $(`#${partId}`);
        const outputItem = $(`#output-item-${partId}`);
        if (!part.length || !outputItem.length) return;

        const varName = part.data('var');
        const type = part.data('type');
        const editor = part.find('.query-part-editor');
        let typeName = '';

        if (editor.is(':visible')) {
            // If editor is open, get the live value from the dropdown
            if (type === 'node') {
                typeName = editor.find('.query-node-type').val() || 'Node';
            } else {
                typeName = editor.find('.query-rel-type').val() || 'Relationship';
            }
        } else {
            // If editor is closed, get the value from the saved state
            const state = part.data('saved-state') || {};
            if (type === 'node') {
                typeName = state.nodeType || 'Node';
            } else {
                typeName = state.relType || 'Relationship';
            }
        }
        
        // Update the text
        outputItem.find('.output-label-text').text(`${varName} (${typeName})`);
    }

    function addQueryPart(type) {
        const container = $('#query-builder-container');
        const lastPart = container.children().last();

        if (container.find('.query-part-container').length === 0) {
            $('#query-output-container').empty();
        }
        const partId = `query-part-${queryBuilderPartCounter++}`;
        const varName = String.fromCharCode(97 + container.find('.query-part-container').length);
        
        const isFirstPart = container.children().length === 0;

        let partHtml = `
            <div class="query-part-container mb-2" id="${partId}" data-type="${type}" data-var="${varName}">
                <div class="query-part-summary">
                    <span class="query-part-summary-text"></span>
                    <div class="query-part-controls">
                        <button class="btn-icon" onclick="toggleQueryEditor('${partId}')">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-pencil-square" viewBox="0 0 16 16"><path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/><path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5v11z"/></svg>
                        </button>
                        <button class="btn-icon" onclick="removeQueryPart('${partId}')">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16"><path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/><path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/></svg>
                        </button>
                    </div>
                </div>
                <div class="query-part-editor" style="display: none;"></div>
            </div>`;
        
        container.append(partHtml);
        
        let initialLabel = type === 'node' ? 'Node' : 'Relationship';
        let outputHtml = `
            <div class="query-output-item" id="output-item-${partId}" data-part-id="${partId}">
                <div class="form-check">
                    <input class="form-check-input output-variable" type="checkbox" value="${varName}" id="output-check-${varName}" onchange="generateCypherQuery()" checked>
                    <label class="form-check-label" for="output-check-${varName}">
                        <strong class="output-label-text">${varName} (${initialLabel})</strong>
                    </label>
                    ${type === 'node' ? `<a href="#" class="property-toggle-arrow ms-2" onclick="toggleOutputProperties('${partId}', event)">[+]</a>` : ''}
                </div>
                ${type === 'node' ? `<div class="query-output-properties" id="output-properties-${partId}" style="display:none; padding-left: 20px;"><small class="text-muted">Select a node type to see properties.</small></div>` : ''}
            </div>`;
        $('#query-output-container').append(outputHtml);


        // Immediately open the editor for the new part
        toggleQueryEditor(partId, true); 
        updateAddRelButtonState();
        generateCypherQuery();
    }

    function removeQueryPart(partId) {
        $(`#${partId}`).remove();
        $(`#output-item-${partId}`).remove();
        // Re-assign variable names
        $('#query-builder-container .query-part-container').each(function(index) {
            const oldId = this.id;
            const newVar = String.fromCharCode(97 + index);
            $(this).data('var', newVar);
            
            const outputItem = $(`#output-item-${oldId}`);
            outputItem.find('.output-variable').val(newVar).attr('id', `output-check-${newVar}`);
            outputItem.find('label').attr('for', `output-check-${newVar}`);
            updateQueryOutputLabel(oldId); // Update the label with the new variable name
        });

        if ($('#query-builder-container .query-part-container').length === 0) {
            $('#query-output-container').html('<small class="text-muted">Add nodes/relationships to the query to select output.</small>');
        }
        updateAddRelButtonState();
        generateCypherQuery();
    }

    function toggleQueryEditor(partId, forceOpen = false) {
        const part = $(`#${partId}`);
        const editor = part.find('.query-part-editor');
        
        if (editor.is(':visible') && !forceOpen) {
            updateQuerySummary(partId); // This saves the state
            editor.slideUp(200, () => editor.empty());
            updateQueryOutputLabel(partId); // Update label from saved state
            generateCypherQuery();
        } else {
            // Build editor content on the fly
            const type = part.data('type');
            let editorHtml = '';
            if (type === 'node') {
                const nodeTypes = Object.keys(typeProperties).sort();
                const typeOptions = nodeTypes.map(t => `<option value="${t}">${t}</option>`).join('');
                editorHtml = `
                    <label class="form-label">Node Type</label>
                    <select class="form-select form-select-sm mb-2 query-node-type">
                        <option value="">-- Any Node --</option>
                        ${typeOptions}
                    </select>
                    <label class="form-label mt-2">Property Filters</label>
                    <div class="query-property-filters mb-2"></div>
                    <div class="input-group input-group-sm">
                        <select class="form-select query-property-select" disabled><option>-- Select Property --</option></select>
                        <select class="form-select query-operator-select" style="max-width: 70px;" disabled>
                            <option value="=">=</option><option value="<>">&lt;&gt;</option><option value=">">&gt;</option><option value="<">&lt;</option><option value=">=">&gt;=</option><option value="<=">&lt;=</option><option value="CONTAINS">CONTAINS</option>
                        </select>
                        <input type="text" class="form-control query-property-value" placeholder="Value..." disabled>
                        <button class="btn btn-outline-secondary add-filter-btn" disabled>+</button>
                    </div>
                    <button class="btn btn-sm btn-primary w-100 mt-3" onclick="toggleQueryEditor('${partId}')">Done</button>
                `;
            } else { // relationship
                const relTypes = [...new Set(fullGraph.edges.map(e => e.label || 'related to'))].sort();
                const relOptions = relTypes.map(t => `<option value="${t}">${t}</option>`).join('');
                 editorHtml = `
                    <label class="form-label">Relationship</label>
                    <div class="input-group input-group-sm">
                        <select class="form-select form-select-sm query-rel-type">
                            <option value="">-- Any Relationship --</option>
                            ${relOptions}
                        </select>
                        <select class="form-select form-select-sm query-rel-direction" style="max-width: 70px;">
                            <option value="->">--&gt;</option><option value="<-">&lt;--</option><option value="-">---</option>
                        </select>
                    </div>
                    <button class="btn btn-sm btn-primary w-100 mt-3" onclick="toggleQueryEditor('${partId}')">Done</button>
                `;
            }
            editor.html(editorHtml);
            
            // Re-attach event listeners and populate data
            editor.find('.add-filter-btn').on('click', () => addQueryPropertyFilter(partId));
            editor.find('.query-node-type').on('change', () => {
                updateQueryNodeProperties(partId);
                updateQueryOutputLabel(partId); // Live update
            });
            editor.find('.query-rel-type').on('change', () => updateQueryOutputLabel(partId)); // Live update
            
            // Restore saved state
            const savedData = part.data('saved-state') || {};
            if (type === 'node') {
                editor.find('.query-node-type').val(savedData.nodeType || '');
                updateQueryNodeProperties(partId); // This will populate properties
                if (savedData.filters) {
                    savedData.filters.forEach(f => {
                         const filterHtml = `<span class="filter-pill" data-prop="${f.prop}" data-op="${f.op}" data-value="${f.value}">
                            ${f.prop} ${f.op} "${f.value}"
                            <button class="remove-filter" onclick="$(this).parent().remove()">&times;</button>
                        </span>`;
                        editor.find('.query-property-filters').append(filterHtml);
                    });
                }
            } else {
                 editor.find('.query-rel-type').val(savedData.relType || '');
                 editor.find('.query-rel-direction').val(savedData.direction || '->');
            }

            editor.slideDown(200, () => updateQueryOutputLabel(partId)); // Update label once editor is open and populated
        }
    }

    function updateQuerySummary(partId) {
        const part = $(`#${partId}`);
        const summaryText = part.find('.query-part-summary-text');
        const type = part.data('type');
        const varName = part.data('var');
        const editor = part.find('.query-part-editor');
        
        let savedState = {};
        let summary = '';

        if (type === 'node') {
            const nodeType = editor.find('.query-node-type').val();
            savedState.nodeType = nodeType;
            summary = `Node (${varName}${nodeType ? ':' + nodeType : ''})`;
            
            savedState.filters = [];
            let filterSummaries = [];
            editor.find('.filter-pill').each(function() {
                const filterData = $(this).data();
                savedState.filters.push(filterData);
                filterSummaries.push(`${filterData.prop} ${filterData.op} "${filterData.value}"`);
            });

            if (filterSummaries.length > 0) {
                summary += ` { ${filterSummaries.join(', ')} }`;
            }
        } else { // relationship
            const relType = editor.find('.query-rel-type').val();
            const direction = editor.find('.query-rel-direction').val();
            savedState.relType = relType;
            savedState.direction = direction;
            const [start, end] = direction === '<-' ? ['<-', '-'] : (direction === '->' ? ['-', '->'] : ['-', '-']);
            summary = `${start}[${varName}${relType ? ':' + relType : ''}]${end}`;
        }
        
        part.data('saved-state', savedState);
        summaryText.text(summary);
        summaryText.attr('title', summary); // For full text on hover
    }

    function updateQueryNodeProperties(partId) {
        const part = $(`#${partId}`);
        const editor = part.find('.query-part-editor');
        const nodeType = editor.find('.query-node-type').val();
        const propSelect = editor.find('.query-property-select');
        const valueInput = editor.find('.query-property-value');
        const addBtn = editor.find('.add-filter-btn');
        const opSelect = editor.find('.query-operator-select');

        propSelect.empty().append('<option>-- Select Property --</option>');
        
        // Update output properties as well
        const outputPropertiesContainer = $(`#output-properties-${partId}`);
        outputPropertiesContainer.empty();
        const varName = part.data('var');

        if (nodeType && typeProperties[nodeType]) {
            const props = Array.from(typeProperties[nodeType]).sort();
            props.forEach(p => {
                propSelect.append(`<option value="${p}">${p}</option>`);
                const propHtml = `<div class="form-check"><input class="form-check-input output-property" type="checkbox" value="${varName}.${p}" onchange="generateCypherQuery()"><label class="form-check-label">${p}</label></div>`;
                outputPropertiesContainer.append(propHtml);
            });
            propSelect.prop('disabled', false);
            valueInput.prop('disabled', false);
            addBtn.prop('disabled', false);
            opSelect.prop('disabled', false);
        } else {
            propSelect.prop('disabled', true);
            valueInput.prop('disabled', true);
            addBtn.prop('disabled', true);
            opSelect.prop('disabled', true);
            outputPropertiesContainer.html('<small class="text-muted">No properties for this type.</small>');
        }
    }

    function addQueryPropertyFilter(partId) {
        const editor = $(`#${partId}`).find('.query-part-editor');
        const prop = editor.find('.query-property-select').val();
        const op = editor.find('.query-operator-select').val();
        const value = editor.find('.query-property-value').val().trim();

        if (prop && value) {
            const filterHtml = `<span class="filter-pill" data-prop="${prop}" data-op="${op}" data-value="${value}">
                ${prop} ${op} "${value}"
                <button class="remove-filter" onclick="$(this).parent().remove()">&times;</button>
            </span>`;
            editor.find('.query-property-filters').append(filterHtml);
            editor.find('.query-property-value').val('');
        }
    }

    function generateCypherQuery() {
        let matchClause = "MATCH ";
        let whereClauses = [];
        let returnClause = "RETURN ";
        
        const parts = $('#query-builder-container .query-part-container');
        
        if (parts.length === 0) {
            $('#cypher-query-display').val("MATCH (n) RETURN n LIMIT 25");
            return;
        }

        let patternParts = [];
        parts.each(function() {
            const part = $(this);
            const varName = part.data('var');
            const type = part.data('type');
            const state = part.data('saved-state') || {};
            
            if (type === 'node') {
                patternParts.push(`(${varName}${state.nodeType ? `:${state.nodeType}` : ''})`);
                if (state.filters) {
                    state.filters.forEach(f => {
                        let value = f.value;
                         if (isNaN(parseFloat(value)) || !isFinite(value)) {
                            value = `"${value.replace(/"/g, '\\"')}"`;
                        }
                        whereClauses.push(`${varName}.${f.prop} ${f.op} ${value}`);
                    });
                }
            } else { // relationship
                const [start, end] = state.direction === '<-' ? ['<-', '-'] : (state.direction === '->' ? ['-', '->'] : ['-', '-']);
                patternParts.push(`${start}[${varName}${state.relType ? `:${state.relType}` : ''}]${end}`);
            }
        });
        
        // This simple join assumes a linear pattern, e.g., (a)-[b]->(c)
        matchClause += patternParts.join('');

        // Aggregations
        const aggregations = $('#aggregation-builder-container .aggregation-row');
        if (aggregations.length > 0) {
            let aggReturnParts = [];
            aggregations.each(function() {
                const func = $(this).find('.agg-function').val();
                const nodeVar = $(this).find('.agg-node').val();
                const prop = $(this).find('.agg-property').val();

                if (func === 'COUNT') {
                    aggReturnParts.push(`count(${nodeVar}) AS ${func.toLowerCase()}_${nodeVar}`);
                } else if (prop) {
                    aggReturnParts.push(`${func.toLowerCase()}(toFloat(${nodeVar}.${prop})) AS ${func.toLowerCase()}_${prop}`);
                }
            });
            returnClause += aggReturnParts.length > 0 ? aggReturnParts.join(', ') : '*';
            $('#query-output-container').css('opacity', '0.5');
        } else {
            let returnParts = [];
            $('#query-output-container .form-check-input:checked').each(function() {
                returnParts.push($(this).val());
            });
            returnClause += returnParts.length > 0 ? returnParts.join(', ') : '*';
            $('#query-output-container').css('opacity', '1');
        }
        
        let finalQuery = matchClause;
        if (whereClauses.length > 0) {
            finalQuery += `\nWHERE ` + whereClauses.join(' AND ');
        }
        finalQuery += `\n${returnClause}`;

        $('#cypher-query-display').val(finalQuery);
    }
    
    function displayTableResults(data) { // data is now { headers: [], rows: [] }
        const modalBody = $('#queryResultModalBody');
        modalBody.empty();

        const headers = data.headers;
        const rows = data.rows;

        if (!rows || rows.length === 0) {
            modalBody.html('<p class="text-center text-muted">The query returned no results.</p>');
            queryResultModal.show();
            return;
        }

        let table = '<table class="table table-bordered table-hover"><thead><tr>';
        headers.forEach(header => {
            table += `<th>${header}</th>`;
        });
        table += '</tr></thead><tbody>';

        rows.forEach(row => {
            table += '<tr>';
            row.forEach(cellData => {
                let displayData = cellData;
                if (typeof displayData === 'object' && displayData !== null) {
                    displayData = JSON.stringify(displayData, null, 2);
                }
                table += `<td>${displayData}</td>`;
            });
            table += '</tr>';
        });

        table += '</tbody></table>';
        modalBody.html(table);
        queryResultModal.show();
    }

    async function runGeneratedQuery() {
        if (currentDataSourceMode !== 'database') {
            showCustomAlert("No database connected.", "Feature Unavailable");
            return;
        }

        const query = $('#cypher-query-display').val();
        const runButton = $('#run-query-btn');
        const originalButtonText = runButton.html();
        
        runButton.html('<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Running...').prop('disabled', true);

        try {
            const response = await fetch('http://localhost:3000/api/query', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query: query })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Server responded with status: ${response.status}`);
            }

            const result = await response.json();
            
            if (result.type === 'graph') {
                processAndRenderGraph(result.data, "Query Result");
                showCustomAlert("Graph results have been loaded into the viewer.", "Query Successful");
            } else if (result.type === 'table') {
                displayTableResults(result.data);
            } else {
                 throw new Error("Unknown result type from server.");
            }

        } catch (error) {
            console.error("Error running query:", error);
            showCustomAlert(`Failed to run query: ${error.message}`, "Query Error");
        } finally {
            runButton.html(originalButtonText).prop('disabled', false);
        }
    }

    function clearQueryBuilder() {
        $('#query-builder-container').empty();
        $('#aggregation-builder-container').empty();
        $('#query-output-container').html('<small class="text-muted">Add nodes/relationships to the query to select output.</small>');
        queryBuilderPartCounter = 0;
        updateAddRelButtonState();
        generateCypherQuery();
    }

    function toggleOutputProperties(partId, event) {
        event.preventDefault();
        const container = $(`#output-properties-${partId}`);
        const link = $(event.target);
        container.slideToggle(200);
        link.text(link.text() === '[+]' ? '[-]' : '[+]');
    }

    function addAggregation() {
        const container = $('#aggregation-builder-container');
        const aggId = `agg-row-${$('.aggregation-row').length}`;
        const nodeParts = $('#query-builder-container .query-part-container[data-type="node"]');
        if (nodeParts.length === 0) {
            showCustomAlert("Please add at least one node to the query before adding an aggregation.");
            return;
        }

        let nodeOptions = '';
        nodeParts.each(function() {
            const varName = $(this).data('var');
            const nodeType = ($(this).data('saved-state') || {}).nodeType || 'Node';
            nodeOptions += `<option value="${varName}" data-node-type="${nodeType}">${varName} (${nodeType})</option>`;
        });

        const aggHtml = `
            <div class="aggregation-row" id="${aggId}">
                <select class="form-select form-select-sm agg-function" style="flex:2;" onchange="toggleAggProperty('${aggId}')">
                    <option value="COUNT">COUNT</option><option value="SUM">SUM</option><option value="AVG">AVG</option><option value="MIN">MIN</option><option value="MAX">MAX</option>
                </select>
                <select class="form-select form-select-sm agg-node" style="flex:2;" onchange="updateAggProperties('${aggId}')">${nodeOptions}</select>
                <select class="form-select form-select-sm agg-property" style="flex:3;" onchange="generateCypherQuery()" disabled><option value="">-- (Node) --</option></select>
                <button class="btn-close btn-sm" onclick="$(this).parent().remove(); generateCypherQuery();"></button>
            </div>`;
        container.append(aggHtml);
        updateAggProperties(aggId);
        toggleAggProperty(aggId);
        generateCypherQuery();
    }

    function toggleAggProperty(aggId) {
        const row = $(`#${aggId}`);
        const func = row.find('.agg-function').val();
        const propSelect = row.find('.agg-property');
        propSelect.prop('disabled', func === 'COUNT').val('');
        generateCypherQuery();
    }

    function updateAggProperties(aggId) {
        const row = $(`#${aggId}`);
        const nodeType = row.find('.agg-node option:selected').data('node-type');
        const propSelect = row.find('.agg-property');
        propSelect.empty().append('<option value="">-- (Node) --</option>');

        if (nodeType && typeProperties[nodeType]) {
            Array.from(typeProperties[nodeType]).sort().forEach(p => propSelect.append(`<option value="${p}">${p}</option>`));
        }
        generateCypherQuery();
    }
    
    function updateAddRelButtonState() {
        const lastPart = $('#query-builder-container .query-part-container').last();
        const addRelBtn = $('#add-rel-btn');
        if (lastPart.length && lastPart.data('type') === 'node') {
            addRelBtn.prop('disabled', false);
        } else {
            addRelBtn.prop('disabled', true);
        }
    }

    // --- START: NEW SCHEMA GRAPH RENDER FUNCTION ---
    async function renderSchemaGraph() {
        $('#viewer-title').text('Database Schema');
        $('#file-name-display').text(cachedSchemaGraph ? '(Live Schema View - Cached)' : '(Loading...)');
        $('#node-count-display').hide();
        
        const displaySchema = (schemaData) => {
            const dynamicGroups = {};
            const pastelColors = ['#a8e6cf', '#dcedc1', '#ffd3b6', '#ffaaa5', '#ff8b94', '#b8a9c9', '#f6eac2', '#b2d8d8', '#ffc0cb', '#fde2e4'];
            let colorIndex = 0;
            schemaData.nodes.forEach(node => {
                if (!dynamicGroups[node.group]) {
                   dynamicGroups[node.group] = { 
                       color: { background: pastelColors[colorIndex % pastelColors.length], border: '#555' }, 
                       font: { color: '#000' } 
                   };
                   colorIndex++;
                }
            });
            network.setOptions({ groups: dynamicGroups, physics: true });
            network.setData(schemaData);
            network.fit();
        };

        if (cachedSchemaGraph) {
            console.log("Using cached schema graph.");
            displaySchema(cachedSchemaGraph);
            return;
        }

        network.setData({ nodes: [], edges: [] }); // Clear view while loading
        try {
            console.log("Fetching schema graph from server for the first time.");
            const response = await fetch('http://localhost:3000/api/schema');
            if (!response.ok) throw new Error('Failed to fetch schema graph from the server.');
            
            const schemaGraph = await response.json();
            cachedSchemaGraph = schemaGraph; // Store in cache
            
            $('#file-name-display').text('(Live Schema View)');
            displaySchema(cachedSchemaGraph);
            
        } catch (error) {
            console.error("Schema view error:", error);
            showCustomAlert('Could not load the schema graph. Is the backend running?', 'Error');
            if (cachedFullGraph) {
                const sourceName = cachedFileName.match(/\(Source: (.*)\)/)?.[1] || "File";
                processAndRenderGraph(cachedFullGraph, sourceName);
                cachedFullGraph = null;
            }
        }
    }
    // --- END: NEW SCHEMA GRAPH RENDER FUNCTION ---

    // --- START: NEW HYBRID MODE FUNCTIONS ---
    async function loadConfiguredFileOntologies() {
	return new Promise(async (resolve, reject) => {
    const selector = $('#fileOntologySelector');
    
    try {
        // 1. Fetch your new config.json file
        const response = await fetch('config.json'); 
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const files = await response.json();

        // 2. Build the <option> elements from the file
        if (files && files.length > 0) {
            let optionsHtml = '<option value="">-- Select a configured file --</option>';
            files.forEach(file => {
                optionsHtml += `<option data-url="${file.url}">${file.name}</option>`;
            });
            selector.html(optionsHtml);
            selector.prop('disabled', false); // Enable the dropdown
        } else {
            selector.html('<option>No configured files found.</option>');
        }
		resolve(files); // Return the loaded file list
    } catch (error) {
        console.error('Error loading file manifest:', error);
        selector.html('<option>Error loading file list.</option>');
		reject(error); // Return the error
    }
	});
    }
    function updateUIMode(mode) {
        console.log(`Switching UI mode to: ${mode}`);
        currentDataSourceMode = mode;
        const queryTab = $('#query-tab');
        const aiTab = $('#ask-ai-tab');
        const runQueryBtn = $('#run-query-btn');

        // Always keep tabs enabled visually
        queryTab.removeClass('disabled-tab').attr('title', '');
        aiTab.removeClass('disabled-tab').attr('title', '');
        
        runQueryBtn.prop('disabled', false); // ALWAYS keep run query button enabled

        if (mode === 'database') {
            runQueryBtn.attr('title', 'Run this query against the live database');
            isDbConnected = true;
        } else { // 'file' or 'none'
            runQueryBtn.attr('title', 'Database connection required to run queries.');
            isDbConnected = false;
        }
    }
    // --- END: NEW HYBRID MODE FUNCTIONS ---

    // --- START: BUILDER FUNCTIONS ---
    function startBuildMode() {
        isBuildMode = true;
        
        if (cachedFullGraph === null && fullGraph.nodes.length > 0) {
            cachedFullGraph = JSON.parse(JSON.stringify(fullGraph));
            cachedFileName = $('#file-name-display').text();
        }

        $('#viewer-title').text('Ontology Builder');
        $('#file-name-display').text('(Editing Canvas)');
        $('#node-count-display').hide();
        detailsPopup.style.display = 'none';

        if (buildGraph.nodes.length === 0) {
            buildNodeCounter = 0;
            buildGraph.nodes.add({ id: `n${buildNodeCounter++}`, label: 'Start Node', properties: {}, group: 'Default', labels: ['Default'] });
        }
        
        network.setOptions(buildOptions(true));
        network.setData(buildGraph);
        network.fit();
    }

    function endBuildMode() {
        isBuildMode = false;
        network.disableEditMode();
        
        if (cachedFullGraph) {
            const sourceName = cachedFileName.match(/\(Source: (.*)\)/)?.[1] || "File";
            $('#viewer-title').text('Ontology Viewer');
            $('#node-count-display').show();
            processAndRenderGraph(cachedFullGraph, sourceName);
            cachedFullGraph = null; 
        } else {
            fullGraph = { nodes: [], edges: [] };
            network.setData({ nodes: [], edges: [] });
            $('#viewer-title').text('Ontology Viewer');
            $('#file-name-display').text('');
        }
    }

    function addBuildNode() {
        const newNodeId = `n${buildNodeCounter++}`;
        buildGraph.nodes.add({
            id: newNodeId,
            label: `New Node ${buildNodeCounter}`,
            properties: {},
            group: 'Default',
            labels: ['Default']
        });
        network.focus(newNodeId, { animation: true });
    }
    
    function initAddBuildEdge() {
        const btn = $('#btn-add-edge');
        if (btn.hasClass('btn-info')) {
            network.disableEditMode();
            btn.removeClass('btn-info').addClass('btn-secondary').text('Add Relationship');
        } else {
            network.addEdgeMode();
            btn.removeClass('btn-secondary').addClass('btn-info').text('Cancel Adding Relationship');
        }
    }
    
    function showBuilderEditModal(element, callback) {
        const { id, type } = element;
        let item = type === 'node' ? buildGraph.nodes.get(id) : buildGraph.edges.get(id);
        const isNewEdge = type === 'edge' && !item;
        
        $('#builderEditModal').data('element', element).data('callback', callback);
        
        if (type === 'node') {
            $('#builderEditModalLabel').text('Edit Node');
            $('#modal-node-editor-section').show();
            $('#modal-edge-editor-section').hide();
            $('#modal-node-label-input').val(item.label);
            $('#modal-node-group-input').val(item.group);
            
            const propsContainer = $('#modal-node-properties-container').empty();
            const props = item.properties || {};
            const propKeys = Object.keys(props);
            if (propKeys.length > 0) {
                propKeys.forEach(key => addPropertyField('#modal-node-properties-container', key, props[key]));
            } else {
                addPropertyField('#modal-node-properties-container', 'Property1', '');
            }
        } else { // edge
            $('#builderEditModalLabel').text(isNewEdge ? 'Create Relationship' : 'Edit Relationship');
            $('#modal-node-editor-section').hide();
            $('#modal-edge-editor-section').show();
            $('#modal-edge-label-input').val(isNewEdge ? 'RELATES_TO' : item.label);
            
            const propsContainer = $('#modal-edge-properties-container').empty();
            const props = isNewEdge ? {} : (item.properties || {});
            const propKeys = Object.keys(props);
            if (propKeys.length > 0) {
                propKeys.forEach(key => addPropertyField('#modal-edge-properties-container', key, props[key]));
            } else {
                addPropertyField('#modal-edge-properties-container', 'Property1', '');
            }
        }
        
        $('#modal-btn-delete').toggle(!isNewEdge);
        builderEditModal.show();
    }

    function addPropertyField(containerId, key = '', value = '') {
        const propHtml = `
            <div class="input-group input-group-sm mb-1 property-row">
                <input type="text" class="form-control prop-key" placeholder="Key" value="${key}">
                <input type="text" class="form-control prop-value" placeholder="Value" value="${value}">
                <button class="btn btn-outline-danger" type="button" onclick="$(this).closest('.property-row').remove()">X</button>
            </div>
        `;
        $(containerId).append(propHtml);
    }

    function saveBuilderModalChanges() {
        const { element, callback } = $('#builderEditModal').data();
        const { id, type } = element;

        if (type === 'node') {
            const newLabel = $('#modal-node-label-input').val().trim();
            const newGroupString = $('#modal-node-group-input').val().trim();
            const newProperties = {};
            $('#modal-node-properties-container .property-row').each(function() {
                const key = $(this).find('.prop-key').val().trim();
                const value = $(this).find('.prop-value').val().trim();
                if (key) newProperties[key] = value;
            });

            const newLabels = newGroupString.split(',').map(s => s.trim()).filter(s => s.length > 0);
            const mainGroup = newLabels[0] || 'Default';

            buildGraph.nodes.update({ id: id, label: newLabel, group: mainGroup, labels: newLabels.length > 0 ? newLabels : ['Default'], properties: newProperties });

        } else { // edge
            const newLabel = $('#modal-edge-label-input').val().trim();
            const newProperties = {};
            $('#modal-edge-properties-container .property-row').each(function() {
                const key = $(this).find('.prop-key').val().trim();
                const value = $(this).find('.prop-value').val().trim();
                if (key) newProperties[key] = value;
            });

            if (callback) { // Finalizing a new edge
                tempEdgeData.label = newLabel;
                tempEdgeData.properties = newProperties;
                callback(tempEdgeData);
                network.disableEditMode();
                $('#btn-add-edge').removeClass('btn-info').addClass('btn-secondary').text('Add Relationship');
            } else { // Updating an existing edge
                buildGraph.edges.update({ id: id, label: newLabel, properties: newProperties });
            }
        }
        builderEditModal.hide();
    }
    
    function deleteSelectedElement() {
        const { element } = $('#builderEditModal').data();
        if (!element) return;
        
        if(element.type === 'node') {
            buildGraph.nodes.remove(element.id); // vis-network also removes connected edges
        } else {
            buildGraph.edges.remove(element.id);
        }
        builderEditModal.hide();
    }

    function saveBuiltOntology() {
        if(buildGraph.nodes.length === 0) {
            showCustomAlert("The ontology is empty. Add some nodes first.");
            return;
        }

        const nodesToSave = buildGraph.nodes.get({
            fields: ['id', 'x', 'y', 'label', 'group', 'properties', 'labels']
        });
        const edgesToSave = buildGraph.edges.get({
             fields: ['from', 'to', 'label', 'properties']
        });
        
        const graphToSave = { nodes: nodesToSave, edges: edgesToSave };
        const blob = new Blob([JSON.stringify(graphToSave, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "my-ontology.json";
        a.click();
        URL.revokeObjectURL(url);
    }

    document.getElementById("uploadOntologyToBuild").addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (e) {
            try {
                const graph = JSON.parse(e.target.result);
                if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(graph.edges)) {
                    throw new Error("Invalid JSON format for ontology.");
                }
                
                buildGraph.nodes.clear();
                buildGraph.edges.clear();
                buildGraph.nodes.add(graph.nodes);
                buildGraph.edges.add(graph.edges);

                let maxId = 0;
                graph.nodes.forEach(node => {
                    const match = String(node.id).match(/^n(\d+)$/);
                    if (match) {
                        const num = parseInt(match[1], 10);
                        if (num > maxId) maxId = num;
                    }
                });
                buildNodeCounter = maxId + 1;

                network.setOptions({ physics: true }); 
                network.fit();
                network.once('stabilizationIterationsDone', () => {
                    network.setOptions({ physics: false });
                });
                // showCustomAlert(`Successfully loaded '${file.name}' into the builder.`);

            } catch (err) {
                console.error("Failed to parse ontology for builder:", err);
                showCustomAlert(`Error loading file: ${err.message}`);
            }
        };
        reader.readAsText(file);
        event.target.value = ''; // Reset file input
    });
    // --- END: BUILDER FUNCTIONS ---


  $('#pathFromTypeSelect').on('change', function() { populateNodeDropdown($(this).val(), $('#pathFromNodeSelect')); });
  $('#pathToTypeSelect').on('change', function() { populateNodeDropdown($(this).val(), $('#pathToNodeSelect')); });
  $('#nodeSelect').on('change', function () {
    let selectedIds = $(this).val();
    if (selectedIds && selectedIds.length > 0) { network.selectNodes(selectedIds); network.fit({ nodes: selectedIds, animation: true }); }
    else if (network) { network.unselectAll(); }
  });
  function selectAllNodeTypes(event) { event.preventDefault(); $('#node-type-filter-container .form-check-input').prop('checked', true); triggerAdvancedFilter(); }
  function deselectAllNodeTypes(event) { event.preventDefault(); $('#node-type-filter-container .form-check-input').prop('checked', false); triggerAdvancedFilter(); }
  
  $('#node-type-filter-container').on('click', '.property-toggle-arrow', function(e) {
    e.preventDefault();
    const type = $(this).data('type');
    const controls = $(this).closest('.node-type-filter-item').find('.property-filter-container');
    const select = controls.find('.property-select');
    if (select.children().length <= 1) {
        const props = Array.from(typeProperties[type] || []).sort();
        props.forEach(prop => select.append(`<option value="${prop}">${prop}</option>`));
    }
    controls.slideToggle(200);
  });
  
  function handleAddPropertyFilter(event) {
      const button = $(event.currentTarget);
      const controls = button.closest('.property-filter-container');
      const prop = controls.find('.property-select').val();
      const valuesString = controls.find('.property-value-input').val().trim();
      if (!prop || !valuesString) return;
      const values = valuesString.split(',').map(v => v.trim()).filter(v => v);
      values.forEach(value => {
        if (controls.find(`.filter-pill[data-prop="${prop}"][data-value="${value.toLowerCase()}"]`).length > 0) return;
        const pill = `<span class="filter-pill" data-prop="${prop}" data-value="${value.toLowerCase()}">${prop}: "${value}"<button class="remove-filter">&times;</button></span>`;
        controls.find('.active-filters-container').append(pill);
      });
      controls.find('.property-value-input').val('');
      triggerAdvancedFilter();
  }
  function handleAddNodeContainsFilter(event) {
      const button = $(event.currentTarget);
      const controls = button.closest('.property-filter-container');
      const textValue = controls.find('.node-contains-value-input').val().trim();
      if (!textValue) return;
      const propIdentifier = "__node_contains__";
      if (controls.find(`.filter-pill[data-prop="${propIdentifier}"][data-value="${textValue.toLowerCase()}"]`).length > 0) return;
      const pill = `<span class="filter-pill" data-prop="${propIdentifier}" data-value="${textValue.toLowerCase()}">Node contains: "${textValue}"<button class="remove-filter">&times;</button></span>`;
      controls.find('.active-filters-container').append(pill);
      controls.find('.node-contains-value-input').val('');
      triggerAdvancedFilter();
  }
  function handleAddNameIsFilter(event) {
      const button = $(event.currentTarget);
      const controls = button.closest('.property-filter-container');
      const textValue = controls.find('.name-is-value-input').val().trim();
      if (!textValue) return;
      const propIdentifier = "__name_is__";
      if (controls.find(`.filter-pill[data-prop="${propIdentifier}"][data-value="${textValue.toLowerCase()}"]`).length > 0) return;
      const pill = `<span class="filter-pill" data-prop="${propIdentifier}" data-value="${textValue.toLowerCase()}">Name is: "${textValue}"<button class="remove-filter">&times;</button></span>`;
      controls.find('.active-filters-container').append(pill);
      controls.find('.name-is-value-input').val('');
      triggerAdvancedFilter();
  }
  function handleRemoveFilter(event) { 
      $(event.currentTarget).closest('.filter-pill').remove(); 
      triggerAdvancedFilter(); 
  }

  function toggleAdvancedSearchBody(event) {
      event.preventDefault();
      const body = $('#advanced-search-body');
      const iconContainer = $('#toggle-advanced-search-body');
      body.slideToggle(200, function() {
          if ($(this).is(':hidden')) {
              iconContainer.html('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-down" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>');
          } else {
              iconContainer.html('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chevron-up" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"/></svg>');
          }
      });
  }

  $(document).ready(async function() { // <-- MAKE THIS ASYNC
    limitModal = new bootstrap.Modal(document.getElementById('limitModal'));
    csvUploadModal = new bootstrap.Modal(document.getElementById('csvUploadModal'));
    customAlertModal = new bootstrap.Modal(document.getElementById('customAlertModal'));
    queryResultModal = new bootstrap.Modal(document.getElementById('queryResultModal'));
    builderEditModal = new bootstrap.Modal(document.getElementById('builderEditModal'));

    $('#nodeSelect').select2({ placeholder: "Select starting node(s) for depth filter", allowClear: true });
    $('#pathFromNodeSelect').select2({ placeholder: "Select 'From' node", allowClear: true });
    $('#pathToNodeSelect').select2({ placeholder: "Select 'To' node", allowClear: true });
    detailsPopupClose.addEventListener('click', () => { detailsPopup.style.display = 'none'; });
    $('#btnLoadOntology').on('click', () => $('#uploadOntology').click());
    $('#btnLoadLayout').on('click', () => $('#uploadLayout').click());
    $('#btnLoadCypher').on('click', () => $('#uploadCypher').click());
    $('#btnLoadOwl').on('click', () => $('#uploadOwl').click());
    $('#btnLoadSynonyms').on('click', () => $('#uploadSynonyms').click());
    
    $('#elasticSearchInput').on('keyup', function(event) {
        if (event.key === 'Enter') {
            $('#elastic-search-results').hide().empty();
            applyAllFilters();
        } else if (event.key === 'Escape') {
             $('#elastic-search-results').hide().empty();
        } else {
            // Debounce the search results update
            clearTimeout(filterTimeout);
            filterTimeout = setTimeout(updateElasticSearchResults, 250);
        }
    });

    $('#elastic-search-results').on('click', '.list-group-item', function() {
        // This directly reads the correct text we stored in step 1.
        const selectedText = $(this).data('full-text');
        $('#elasticSearchInput').val(selectedText);
        $('#elastic-search-results').hide().empty();
        applyAllFilters();
    });

    // Hide dropdown when clicking elsewhere
    $(document).on('click', function(event) {
        if (!$(event.target).closest('#live-search-wrapper').length) {
            $('#elastic-search-results').hide().empty();
        }
    });

    $('#node-type-filter-container').on('keydown', '.property-value-input, .node-contains-value-input, .name-is-value-input', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            $(this).siblings('button').click();
        }
    });
    
    $('#physicsToggle, #renderToggle').on('change', function() {
        if (!network || fullGraph.nodes.length === 0) return;
        const newOptions = buildOptions();
        network.setOptions(newOptions);
        if (!document.getElementById('physicsToggle').checked) {
            network.setOptions({ physics: true });
        }
    });

    $('#clusterToggle').on('change', function() {
        if (!network || fullGraph.nodes.length === 0) return;
        handleClustering();
    });

    $('#clear-live-search').on('click', clearLiveSearch);
    $('#clear-depth-filter').on('click', clearDepthFilter);
    $('#clear-advanced-search').on('click', clearAdvancedSearch);
    
    // Query Builder Event Listeners
    $('#add-node-btn').on('click', () => addQueryPart('node'));
    $('#add-rel-btn').on('click', () => addQueryPart('relationship'));
    $('#add-aggregation-btn').on('click', addAggregation);
    $('#clear-query-btn').on('click', clearQueryBuilder);
    $('#query-tab-pane').on('keydown', '.query-property-value', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            const partId = $(this).closest('.query-part-container').attr('id');
            addQueryPropertyFilter(partId);
        }
    });

    // --- BUILDER EVENT LISTENERS ---
    $('#btn-add-node').on('click', addBuildNode);
    $('#btn-add-edge').on('click', initAddBuildEdge);
    $('#btn-save-ontology').on('click', saveBuiltOntology);
    $('#btn-load-ontology-to-build').on('click', () => $('#uploadOntologyToBuild').click());
    $('#modal-btn-add-property').on('click', () => addPropertyField('#modal-node-properties-container'));
    $('#modal-btn-add-edge-property').on('click', () => addPropertyField('#modal-edge-properties-container'));
    $('#modal-btn-save').on('click', saveBuilderModalChanges);
    $('#modal-btn-delete').on('click', deleteSelectedElement);
    document.getElementById('builderEditModal').addEventListener('hidden.bs.modal', event => {
        const { callback } = $('#builderEditModal').data();
        if(callback) {
            callback(null); // Passing null cancels the edge creation
            network.disableEditMode();
            $('#btn-add-edge').removeClass('btn-info').addClass('btn-secondary').text('Add Relationship');
        }
    });


    // --- MODIFIED TAB SWITCHING LOGIC ---
    const mainGraphTabs = ['#upload-tab-pane', '#analysis-tab-pane', '#help-tab-pane'];
    const schemaGraphTabs = ['#query-tab-pane', '#ask-ai-tab-pane'];
    const buildTab = '#build-tab-pane';

    document.querySelectorAll('#sidebar-tabs .nav-link').forEach(tab => {
        tab.addEventListener('show.bs.tab', async function(event) {
            const targetTabId = event.target.getAttribute('data-bs-target');
            const previousTabId = event.relatedTarget ? event.relatedTarget.getAttribute('data-bs-target') : null;

            // This logic is for PREPARING the view before it's shown
            if (targetTabId === buildTab && previousTabId !== buildTab) {
                startBuildMode();
            } else if (targetTabId !== buildTab && previousTabId === buildTab) {
                endBuildMode();
            }

            const wasOnSchema = schemaGraphTabs.includes(previousTabId);
            const isMovingToSchema = schemaGraphTabs.includes(targetTabId);
            
            // Only render schema if we are in DB mode.
            if (isMovingToSchema && !wasOnSchema && currentDataSourceMode === 'database') {
                if (cachedFullGraph === null) {
                    cachedFullGraph = JSON.parse(JSON.stringify(fullGraph));
                    cachedFileName = $('#file-name-display').text();
                }
                renderSchemaGraph();
            } else if (!isMovingToSchema && wasOnSchema) {
                 if (cachedFullGraph !== null) {
                    const sourceName = cachedFileName.match(/\(Source: (.*)\)/)?.[1] || "File";
                    $('#viewer-title').text('Ontology Viewer');
                    $('#node-count-display').show();
                    processAndRenderGraph(cachedFullGraph, sourceName);
                    cachedFullGraph = null;
                 }
            }
        });

        tab.addEventListener('shown.bs.tab', function(event) {
            const targetTabId = event.target.getAttribute('data-bs-target');
            const isMovingToProtectedTab = schemaGraphTabs.includes(targetTabId);

            // This logic runs AFTER the tab is shown
            if (isMovingToProtectedTab && currentDataSourceMode !== 'database') {
                if (targetTabId === '#query-tab-pane') {
                    showCustomAlert("Please connect to Graph data store in 'Upload' section 'Load from Database'", "No graph data store connected");
                } 
                // The 'else if' for '#ask-ai-tab-pane' has been intentionally removed
                // to allow the tab to function in file mode.
            }
        });
    }); // <-- THIS IS THE MISSING LINE THAT FIXES THE BUG
    // --- END: MODIFIED TAB SWITCHING LOGIC ---

    document.getElementById('further-details-link').href = "https.www.example.com";
    initNetwork();
    initResizer();

    // --- START: INITIALIZE HYBRID MODE ---
    let configFiles = null;
    try {
        // Wait for the config file to be loaded and processed
        configFiles = await loadConfiguredFileOntologies();
    } catch (error) {
        console.error("Failed to load config, URL parameters may not work.", error);
    }
    
    // Auto-load default synonyms if the URL is set
    if (DEFAULT_SYNONYM_URL) {
        loadSynonymsFromUrl(DEFAULT_SYNONYM_URL);
    }
    updateUIMode('none'); // Start with DB features disabled
    // --- END: INITIALIZE HYBRID MODE ---
	// --- START: NEW CODE FOR TAB LINKING ---
    function openTabFromHash() {
        const hash = window.location.hash.substring(1); // Get hash, remove '#'
        if (!hash) return; // Do nothing if no hash

        // Map the simple hash name to the actual tab button's ID
        const tabMap = {
            'upload': '#upload-tab',
            'analysis': '#analysis-tab',
            'build': '#build-tab',
            'query': '#query-tab',
            'ai': '#ask-ai-tab',
            'help': '#help-tab'
        };

        const tabButtonId = tabMap[hash];
        if (tabButtonId) {
            const tabButton = document.querySelector(tabButtonId);
            if (tabButton) {
                // Use Bootstrap's own method to show the tab
                const tab = new bootstrap.Tab(tabButton);
                tab.show();
            }
        }
    }
    
    // Run this *first* to show the correct tab
    openTabFromHash();
    
    // Now, run the URL handler, passing in the config we just loaded
	await handleUrlParametersOnLoad(configFiles);
    // --- END: NEW CODE FOR TAB LINKING ---
	// Version infor - Supporting ontology specific load for file based
  });
</script>

</body>
</html>